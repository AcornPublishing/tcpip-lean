CCS PCM C Compiler, Version 2.693, 3951

               Filename: C:\CHIPWEB\PCM\P16WEB.LST

               ROM used: 6840 (83%)
                         Largest free fragment is 761
               RAM used: 177 (48%) at main() level
                         214 (58%) worst case
               Stack:    7 locations

0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   4AB
0003:  NOP
....................  /* PIC Ethernet Web server; runs on the Microchip PICDEM.net board 
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
.................... /* 
.................... ** v0.01 JPB 1/12/00 First version 
.................... ** v0.02 JPB 7/12/00 Simple LCD driver added 
.................... ** v0.04 JPB 10/12/00 Added simple Ethernet transmit 
.................... **                    Added simple EEROM check 
.................... ** v0.05 JPB 17/12/00 Renamed from PICT77 to ETHERPIC 
.................... ** v0.06 JPB 23/12/00 Got ARP working 
.................... ** v0.07 JPB 26/12/00 Got Ping working 
.................... ** v0.08 JPB 26/12/00 Improved Tx throughput 
.................... ** v0.09 JPB 27/12/00 Added support for 64-byte ping 
.................... ** v0.10 JPB 27/12/00 Added support for new (v3) PICDEM-NET board 
.................... ** v0.11 JPB 28/12/00 Added preliminary TCP code 
.................... ** v0.12 JPB 29/12/00 Added dummy daytime service 
.................... ** v0.13 JPB 29/12/00 Started boot configuration 
.................... **                    Increased NIC RAM size from 20h to 40h pages 
.................... **                    Fixed ICMP checksum problem 
.................... ** v0.14 JPB 30/12/00 Added RX_BUFFERED option (to eliminate Rx buffer!) 
.................... ** v0.15 JPB 30/12/00 Added first Web page 
.................... ** v0.16 JPB 30/12/00 Split internal & external Tx length words 
.................... ** v0.17 JPB 1/1/01   Fixed bugs in TCP transmission and length calculation 
.................... **                    Improved debug output 
.................... ** v0.18 JPB 3/1/01   Added UDP echo capability 
.................... **                    Added skeletal FTP for test 
.................... ** v0.19 JPB 4/1/01   Added TFTP 
.................... ** v0.20 JPB 5/1/01   Added TFTP receive 
.................... ** v0.21 JPB 6/1/01   Added EEROM programming to TFTP receive 
.................... ** v0.22 JPB 6/1/01   Stripped out unnecessary functions 
.................... **                    Added user configuration interface 
.................... ** v0.23 JPB 7/1/01   Added non-volatile config 
.................... ** v0.24 JPB 7/1/01   Added EGI variable substitution 
.................... **                    Reduced Ether RAM size to 8K 
.................... ** v0.25 JPB 21/1/01  Switched from TFTP to Xmodem for EEROM programming 
.................... ** v0.26 JPB 25/1/01  Added Fuji display initialisation 
.................... ** v0.27 JPB 28/1/01  Adapted for new design of Web pages 
.................... **                    Sign on as ChipWeb 
.................... ** v1.02 JPB 11/2/01  Added digital I/P 
.................... **                    Up-issued for release 
.................... ** v1.03 JPB 5/3/01   Fixed problem with blank Web page ROM error msg 
.................... */            
....................  
.................... #define SIGNON  "ChipWeb v1.03\n" 
....................  
.................... #define DEBUG        0          // Set non-zero to enable diagnostic printout 
.................... #define OLD_BOARD    0          // Set non-zero if using old PICDEM.NET board 
.................... #define RX_BUFFERED  0          // Set non-zero if using Rx buffers  
.................... #define CLOCK16      0          // Set non-zero if using 16 MHz clock */ 
....................  
.................... #include <16F877.H> 
....................  //////// Standard Header file for the PIC16F877 device //////// 
.................... #device PIC16F877 
.................... #list 
.................... 
.................... #device *=16 
....................  
.................... #FUSES HS,NOWDT,NOPROTECT,PUT,BROWNOUT,NOLVP // PIC fuse settings 
.................... #ID CHECKSUM                                 // ID bytes are checksum 
.................... #ZERO_RAM                                    // Wipe RAM for safety 
.................... #use fast_io(A)                              // I'll set the direction bits 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
....................  
.................... #use I2C(MASTER, SDA=PIN_C4, SCL=PIN_C3, RESTART_WDT, FAST) 
*
03B0:  MOVLW  08
03B1:  MOVWF  78
03B2:  NOP
03B3:  CLRWDT
03B4:  BCF    07,3
03B5:  BSF    03,5
03B6:  BCF    07,3
03B7:  CLRWDT
03B8:  BCF    03,5
03B9:  BSF    03,6
03BA:  RLF    45,F
03BB:  BCF    03,6
03BC:  BCF    07,4
03BD:  BTFSS  03,0
03BE:  GOTO   3C2
03BF:  BSF    03,5
03C0:  BSF    07,4
03C1:  BCF    03,5
03C2:  BTFSC  03,0
03C3:  GOTO   3C7
03C4:  BSF    03,5
03C5:  BCF    07,4
03C6:  BCF    03,5
03C7:  BSF    03,5
03C8:  BSF    07,3
03C9:  BCF    03,5
03CA:  BTFSS  07,3
03CB:  GOTO   3CA
03CC:  DECFSZ 78,F
03CD:  GOTO   3B2
03CE:  CLRWDT
03CF:  BCF    07,3
03D0:  BSF    03,5
03D1:  BCF    07,3
03D2:  NOP
03D3:  BSF    07,4
03D4:  CLRWDT
03D5:  CLRWDT
03D6:  CLRWDT
03D7:  CLRWDT
03D8:  BSF    07,3
03D9:  BCF    03,5
03DA:  BTFSS  07,3
03DB:  GOTO   3DA
03DC:  CLRF   78
03DD:  CLRWDT
03DE:  BTFSC  07,4
03DF:  BSF    78,0
03E0:  CLRWDT
03E1:  BCF    07,3
03E2:  BSF    03,5
03E3:  BCF    07,3
03E4:  BCF    03,5
03E5:  BCF    07,4
03E6:  BSF    03,5
03E7:  BCF    07,4
03E8:  BCF    03,5
03E9:  RETLW  00
*
0DE8:  MOVLW  08
0DE9:  BSF    03,6
0DEA:  MOVWF  49
0DEB:  BCF    03,6
0DEC:  MOVF   77,W
0DED:  BSF    03,6
0DEE:  MOVWF  4A
0DEF:  BCF    03,6
0DF0:  BSF    03,5
0DF1:  BSF    07,4
0DF2:  CLRWDT
0DF3:  BSF    07,3
0DF4:  BCF    03,5
0DF5:  BTFSS  07,3
0DF6:  GOTO   5F5
0DF7:  BTFSC  07,4
0DF8:  BSF    03,0
0DF9:  BTFSS  07,4
0DFA:  BCF    03,0
0DFB:  RLF    78,F
0DFC:  CLRWDT
0DFD:  BSF    03,5
0DFE:  BCF    07,3
0DFF:  BCF    03,5
0E00:  BCF    07,3
0E01:  BSF    03,6
0E02:  DECFSZ 49,F
0E03:  GOTO   605
0E04:  GOTO   607
0E05:  BCF    03,6
0E06:  GOTO   5F0
0E07:  BSF    03,5
0E08:  BCF    03,6
0E09:  BSF    07,4
0E0A:  CLRWDT
0E0B:  BCF    03,5
0E0C:  BCF    07,4
0E0D:  BSF    03,6
0E0E:  MOVF   4A,W
0E0F:  BTFSC  03,2
0E10:  GOTO   616
0E11:  BSF    03,5
0E12:  BCF    03,6
0E13:  BCF    07,4
0E14:  BCF    03,5
0E15:  BSF    03,6
0E16:  BCF    03,6
0E17:  NOP
0E18:  BSF    03,5
0E19:  BSF    07,3
0E1A:  BCF    03,5
0E1B:  BTFSS  07,3
0E1C:  GOTO   61B
0E1D:  CLRWDT
0E1E:  BCF    07,3
0E1F:  BSF    03,5
0E20:  BCF    07,3
0E21:  CLRWDT
0E22:  BCF    03,5
0E23:  BCF    07,4
0E24:  BSF    03,5
0E25:  BCF    07,4
0E26:  BCF    03,5
0E27:  RETLW  00
....................  
.................... #define EEROM_ADDR   0xa0   // i2c addr for eerom 
....................  
.................... // Timer 1 trigger value; tick time = (1024 x DIV) / CPU_CLK 
.................... // 50 ms ticks with 7.3728 MHz clock requires divisor 45 prescale 8 
.................... #if CLOCK16 
.................... #define TIMER1_DIV  98 
.................... #use DELAY(CLOCK=16000000) 
.................... #else 
.................... #define TIMER1_DIV  120 
.................... #use DELAY(CLOCK=19660800) 
*
00ED:  MOVLW  33
00EE:  MOVWF  04
00EF:  BSF    03,7
00F0:  MOVF   00,W
00F1:  BTFSC  03,2
00F2:  GOTO   102
00F3:  MOVLW  06
00F4:  MOVWF  78
00F5:  CLRF   77
00F6:  DECFSZ 77,F
00F7:  GOTO   0F6
00F8:  DECFSZ 78,F
00F9:  GOTO   0F5
00FA:  MOVLW  5A
00FB:  MOVWF  77
00FC:  DECFSZ 77,F
00FD:  GOTO   0FC
00FE:  NOP
00FF:  NOP
0100:  DECFSZ 00,F
0101:  GOTO   0F3
0102:  RETLW  00
.................... #endif 
.................... #define TIMER1_SET  (T1_INTERNAL | T1_DIV_BY_8) 
....................  
.................... #use RS232 (BAUD=9600, XMIT=PIN_C6, RCV=PIN_C7, ERRORS) 
*
02BF:  BTFSS  0C,5
02C0:  GOTO   2BF
02C1:  MOVF   18,W
02C2:  MOVWF  20
02C3:  MOVF   1A,W
02C4:  MOVWF  78
02C5:  BTFSS  20,1
02C6:  GOTO   2C9
02C7:  BCF    18,4
02C8:  BSF    18,4
02C9:  NOP
02CA:  RETLW  00
....................  
.................... #define WORD unsigned long  // Data type definitions 
.................... #define BOOL short          // 'short' is very short (1 bit) in this compiler 
.................... typedef union               // Longword definition (not a native type) 
.................... { 
....................     BYTE b[4]; 
....................     WORD w[2]; 
....................     BYTE l; 
.................... } LWORD; 
....................  
.................... #byte   PORTA = 5               // Main I/O ports 
.................... #byte   PORTB = 6 
.................... #byte   PORTC = 7 
.................... #define ALL_OUT 0 
.................... #define ALL_IN  0xff 
....................  
.................... #if OLD_BOARD 
.................... #BIT DIAG_LED = PORTA.5 
.................... #else 
.................... #bit USER_BUTTON=PORTB.5        // User pushbutton 
.................... #bit USERLED1 = PORTA.2         // User LEDs 
.................... #bit USERLED2 = PORTA.3 
.................... #bit SYSLED   = PORTA.4         // System LED 
.................... #endif 
....................  
.................... #define LEDTIME 10              // Interval for toggling system LED 
....................  
.................... WORD adc1, adc2;                // Copy of current ADC values 
.................... int tickcount;                  // Timer tick count 
.................... BOOL ledon;                     // LED state 
.................... unsigned ledticks;              // LED tick count 
.................... WORD tpxdlen;                   // Length of external data in Tx frame 
....................  
.................... /* General prototypes */ 
.................... void displays(BYTE b); 
....................  
.................... /* Local prototypes */ 
.................... BOOL geticks(void); 
.................... BOOL timeout(int &var, int tout); 
.................... void scan_io(void); 
.................... BOOL read_nonvol(void); 
.................... BYTE csum_nonvol(void); 
.................... void user_config(void); 
....................  
.................... /* Character O/P for debugging */ 
.................... #if DEBUG 
.................... #define DEBUG_PUTC(c) putchar(c) 
.................... #else 
.................... #define DEBUG_PUTC(c) 
.................... #endif 
....................  
.................... /* For PCM compiler, library code must be included (can't be linked) */ 
.................... #include "\chipweb\pcm\p16_eth.h" 
....................  /* RTL8019AS network driver for ChipWeb on PICDEM.net board 
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
.................... /* 
.................... ** v0.01 JPB 25/11/00  Adapted from ETHERNE.C v0.25 
.................... */ 
....................  
.................... #byte   PORTD       = 8 
.................... #byte   PORTE       = 9 
....................  
.................... #BIT    NIC_RESET   = PORTE.2 
.................... #BIT    NIC_IOW_    = PORTE.1 
.................... #BIT    NIC_IOR_    = PORTE.0 
.................... #BYTE   NIC_ADDR    = PORTB 
.................... #BYTE   NIC_DATA    = PORTD 
.................... #define DATA_TO_NIC   set_tris_d(ALL_OUT); 
.................... #define DATA_FROM_NIC set_tris_d(ALL_IN); 
....................  
.................... #define PROMISC  0              /* Set non-zero to accept all packets */ 
....................  
.................... /* Ethernet definitions.. */ 
.................... #define MINFRAME  60 
.................... #define MINFRAMEC 64 
.................... #define CRCLEN    4 
.................... #define MAXFRAME  1514 
.................... #define MAXFRAMEC 1518 
....................  
.................... /* NE2000 definitions */ 
.................... #define DATAPORT 0x10 
.................... #define NE_RESET 0x1f 
....................  
.................... /* 8390 Network Interface Controller (NIC) page0 register offsets */ 
.................... #define CMDR    0x00            /* command register for read & write */ 
.................... #define PSTART  0x01            /* page start register for write */ 
.................... #define PSTOP   0x02            /* page stop register for write */ 
.................... #define BNRY    0x03            /* boundary reg for rd and wr */ 
.................... #define TPSR    0x04            /* tx start page start reg for wr */ 
.................... #define TBCR0   0x05            /* tx byte count 0 reg for wr */ 
.................... #define TBCR1   0x06            /* tx byte count 1 reg for wr */ 
.................... #define ISR     0x07            /* interrupt status reg for rd and wr */ 
.................... #define RSAR0   0x08            /* low byte of remote start addr */ 
.................... #define RSAR1   0x09            /* hi byte of remote start addr */ 
.................... #define RBCR0   0x0A            /* remote byte count reg 0 for wr */ 
.................... #define RBCR1   0x0B            /* remote byte count reg 1 for wr */ 
.................... #define RCR     0x0C            /* rx configuration reg for wr */ 
.................... #define TCR     0x0D            /* tx configuration reg for wr */ 
.................... #define DCR     0x0E            /* data configuration reg for wr */ 
.................... #define IMR     0x0F            /* interrupt mask reg for wr */ 
....................  
.................... /* NIC page 1 register offsets */ 
.................... #define PAR0    0x01            /* physical addr reg 0 for rd and wr */ 
.................... #define CURRP   0x07            /* current page reg for rd and wr */ 
.................... #define MAR0    0x08            /* multicast addr reg 0 for rd and WR */ 
....................  
.................... /* NIC page 3 register offsets */ 
.................... #define RTL9346CR 0x01          /* RTL 9346 command reg */  
.................... #define RTL3    0x06            /* RTL config reg 3 */ 
....................  
.................... /* NIC RAM definitions */ 
.................... #define RAMPAGES 0x20           /* Total number of 256-byte RAM pages */ 
.................... #define TXSTART  0x40           /* Tx buffer start page */ 
.................... #define TXPAGES  6              /* Pages for Tx buffer */ 
.................... #define RXSTART  (TXSTART+TXPAGES)      /* Rx buffer start page */ 
.................... #define RXSTOP   (TXSTART+RAMPAGES-1)   /* Last Rx buffer page */ 
.................... #define DCRVAL   0x48           /* Value for data config reg */ 
....................  
.................... #define MACLEN   6 
.................... BYTE myeth[MACLEN] = {0x00, 0x04, 0xa3, 0, 0, 0}; 
.................... int next_page; 
.................... BYTE curr_rx_page; 
....................  
.................... typedef struct {                // NIC hardware packet header 
....................     BYTE stat;                  //     Error status 
....................     BYTE next;                  //     Pointer to next block 
....................     WORD len;                   //     Length of this frame incl. CRC 
.................... } NICHEADER; 
....................  
.................... typedef struct {                // Ethernet frame header  
....................     BYTE dest[MACLEN];          //     Dest & srce MAC addresses  
....................     BYTE srce[MACLEN]; 
....................     WORD pcol;                  //     Protocol  
.................... } ETHERHEADER; 
....................  
.................... typedef struct {                // NIC and Ethernet headers combined 
....................     NICHEADER nic; 
....................     ETHERHEADER eth; 
.................... } NICETHERHEADER; 
....................  
.................... NICETHERHEADER nicin;           // Buffer for incoming NIC & Ether hdrs  
....................  
.................... WORD rxin, rxout;               // Rx buffer counts (NIC RAM is buffer) 
.................... BOOL atend; 
....................  
.................... #define TXBUFFLEN 64             
.................... BYTE txbuff[TXBUFFLEN];         // Tx buffer 
.................... int txin, txout; 
....................  
.................... /* Prototypes */ 
.................... void setnic_addr(WORD addr); 
.................... WORD getnic_addr(void); 
.................... BYTE getnic_byte(void); 
.................... int getnic_data(BYTE *data, int len); 
.................... int getnic_rx(WORD addr, WORD len); 
.................... void putnic_byte(BYTE b); 
.................... void putnic_data(BYTE *data, int len); 
.................... BYTE nicwrap(int page); 
.................... BYTE innic(int reg); 
.................... void outnic(int reg, int b); 
....................  
.................... /* Prototypes for network driver */ 
.................... BYTE getch_net(void); 
.................... void putch_net(BYTE b); 
.................... void check_byte(BYTE b); 
.................... void swapw(WORD &val); 
....................  
.................... /* Return non-zero if MAC address is a broadcast */ 
.................... BOOL is_mac_bcast(BYTE *addr) 
.................... { 
....................     return((addr[0] & addr[1] & addr[2] & addr[3] & addr[4] & addr[5]) == 0xff); 
.................... } 
....................  
.................... /* Get a byte from network buffer; if end, set flag */ 
.................... BYTE getch_net(void) 
.................... { 
*
0A69:  BSF    03,6
0A6A:  CLRF   37
....................     BYTE b=0; 
....................  
....................     atend = rxout>=rxin; 
0A6B:  BCF    03,6
0A6C:  MOVF   47,W
0A6D:  SUBWF  45,W
0A6E:  BTFSS  03,0
0A6F:  GOTO   27C
0A70:  MOVF   47,W
0A71:  SUBWF  45,W
0A72:  BTFSS  03,2
0A73:  GOTO   27A
0A74:  MOVF   46,W
0A75:  SUBWF  44,W
0A76:  BTFSC  03,2
0A77:  GOTO   27C
0A78:  BTFSS  03,0
0A79:  GOTO   27C
0A7A:  BCF    26,1
0A7B:  GOTO   27D
0A7C:  BSF    26,1
....................     if (!atend) 
0A7D:  BTFSC  26,1
0A7E:  GOTO   28C
....................     { 
....................         b = getnic_byte(); 
0A7F:  CALL   224
0A80:  MOVF   78,W
0A81:  BSF    03,6
0A82:  MOVWF  37
....................         rxout++; 
0A83:  BCF    03,6
0A84:  INCF   46,F
0A85:  BTFSC  03,2
0A86:  INCF   47,F
....................         check_byte(b); 
0A87:  BSF    03,6
0A88:  MOVF   37,W
0A89:  MOVWF  3E
0A8A:  BCF    03,6
0A8B:  CALL   249
....................     } 
....................     return(b); 
0A8C:  BSF    03,6
0A8D:  MOVF   37,W
0A8E:  BCF    03,6
0A8F:  MOVWF  78
0A90:  RETLW  00
.................... } 
....................  
.................... /* Put a byte into the network buffer */ 
.................... void putch_net(BYTE b) 
.................... { 
....................     if (txin < TXBUFFLEN) 
*
0AB1:  MOVLW  40
0AB2:  SUBWF  48,W
0AB3:  BTFSC  03,0
0AB4:  GOTO   2C0
....................         txbuff[txin++] = b; 
0AB5:  MOVF   48,W
0AB6:  INCF   48,F
0AB7:  MOVWF  77
0AB8:  MOVLW  A0
0AB9:  ADDWF  77,W
0ABA:  MOVWF  04
0ABB:  BCF    03,7
0ABC:  BSF    03,6
0ABD:  MOVF   3C,W
0ABE:  MOVWF  00
0ABF:  BCF    03,6
....................     check_byte(b); 
0AC0:  BSF    03,6
0AC1:  MOVF   3C,W
0AC2:  MOVWF  3E
0AC3:  BCF    03,6
0AC4:  CALL   249
0AC5:  RETLW  00
.................... } 
....................      
.................... /* Set up the I/O ports, reset the NIC */ 
.................... void reset_ether(void) 
.................... { 
....................     DATA_FROM_NIC; 
*
00DA:  MOVLW  FF
00DB:  BSF    03,5
00DC:  MOVWF  08
....................     NIC_ADDR = 0; 
00DD:  BCF    03,5
00DE:  CLRF   06
....................     port_b_pullups(TRUE); 
00DF:  MOVLW  81
00E0:  MOVWF  04
00E1:  BCF    03,7
00E2:  BCF    00,7
....................     set_tris_b(0xe0); 
00E3:  MOVLW  E0
00E4:  TRIS   6
....................     NIC_IOW_ = NIC_IOR_ = 1; 
00E5:  BSF    09,0
00E6:  BSF    09,1
....................     NIC_RESET = 1; 
00E7:  BSF    09,2
....................     set_tris_e(ALL_OUT); 
00E8:  MOVLW  00
00E9:  BSF    03,5
00EA:  MOVWF  09
00EB:  BCF    03,5
00EC:  RETLW  00
.................... } 
....................  
.................... /* Initialise card given driver type and base addr. 
.................... ** Return driver type, 0 if error */ 
.................... int init_ether(void) 
.................... { 
....................     int ok=0, i; 
*
06C9:  BSF    03,6
06CA:  CLRF   2D
....................     BYTE b; 
....................  
....................     reset_ether(); 
06CB:  BCF    03,6
06CC:  CALL   0DA
....................     delay_ms(2); 
06CD:  MOVLW  02
06CE:  BSF    03,6
06CF:  MOVWF  33
06D0:  BCF    03,6
06D1:  CALL   0ED
....................     NIC_RESET = 0; 
06D2:  BCF    09,2
....................     delay_ms(2); 
06D3:  MOVLW  02
06D4:  BSF    03,6
06D5:  MOVWF  33
06D6:  BCF    03,6
06D7:  CALL   0ED
....................     outnic(NE_RESET, innic(NE_RESET));  /* Do reset */ 
06D8:  MOVLW  1F
06D9:  BSF    03,6
06DA:  MOVWF  3F
06DB:  BCF    03,6
06DC:  CALL   6A2
06DD:  MOVF   78,W
06DE:  BSF    03,6
06DF:  MOVWF  30
06E0:  MOVLW  1F
06E1:  MOVWF  40
06E2:  MOVF   30,W
06E3:  MOVWF  41
06E4:  BCF    03,6
06E5:  CALL   6B5
....................     delay_ms(2); 
06E6:  MOVLW  02
06E7:  BSF    03,6
06E8:  MOVWF  33
06E9:  BCF    03,6
06EA:  CALL   0ED
....................     if ((innic(ISR) & 0x80) == 0)       /* Report if failed */ 
06EB:  MOVLW  07
06EC:  BSF    03,6
06ED:  MOVWF  3F
06EE:  BCF    03,6
06EF:  CALL   6A2
06F0:  MOVF   78,W
06F1:  ANDLW  80
06F2:  IORLW  00
06F3:  BTFSS  03,2
06F4:  GOTO   70A
....................     { 
....................         printf(displays, "\nNIC init err "); 
*
0004:  BCF    0A,0
0005:  BCF    0A,1
0006:  BCF    0A,2
0007:  ADDWF  02,F
0008:  RETLW  0A
0009:  RETLW  4E
000A:  RETLW  49
000B:  RETLW  43
000C:  RETLW  20
000D:  RETLW  69
000E:  RETLW  6E
000F:  RETLW  69
0010:  RETLW  74
0011:  RETLW  20
0012:  RETLW  65
0013:  RETLW  72
0014:  RETLW  72
0015:  RETLW  20
0016:  RETLW  00
*
06F5:  BSF    03,6
06F6:  CLRF   30
06F7:  BCF    03,6
06F8:  BSF    03,6
06F9:  MOVF   30,W
06FA:  BCF    03,6
06FB:  CALL   004
06FC:  BSF    03,6
06FD:  INCF   30,F
06FE:  MOVWF  31
06FF:  BCF    03,6
0700:  CALL   185
0701:  MOVLW  0E
0702:  BSF    03,6
0703:  SUBWF  30,W
0704:  BTFSC  03,2
0705:  GOTO   708
0706:  BCF    03,6
0707:  GOTO   6F8
....................     } 
....................     else 
0708:  BCF    03,6
0709:  GOTO   7D1
....................     { 
....................         outnic(CMDR, 0x21);                 /* Stop, DMA abort, page 0 */ 
070A:  BSF    03,6
070B:  CLRF   40
070C:  MOVLW  21
070D:  MOVWF  41
070E:  BCF    03,6
070F:  CALL   6B5
....................         delay_ms(2);                        /* ..wait to take effect */ 
0710:  MOVLW  02
0711:  BSF    03,6
0712:  MOVWF  33
0713:  BCF    03,6
0714:  CALL   0ED
....................         outnic(DCR, DCRVAL); 
0715:  MOVLW  0E
0716:  BSF    03,6
0717:  MOVWF  40
0718:  MOVLW  48
0719:  MOVWF  41
071A:  BCF    03,6
071B:  CALL   6B5
....................         outnic(RBCR0, 0);                   /* Clear remote byte count */ 
071C:  MOVLW  0A
071D:  BSF    03,6
071E:  MOVWF  40
071F:  CLRF   41
0720:  BCF    03,6
0721:  CALL   6B5
....................         outnic(RBCR1, 0); 
0722:  MOVLW  0B
0723:  BSF    03,6
0724:  MOVWF  40
0725:  CLRF   41
0726:  BCF    03,6
0727:  CALL   6B5
....................         outnic(RCR, 0x20);                  /* Rx monitor mode */ 
0728:  MOVLW  0C
0729:  BSF    03,6
072A:  MOVWF  40
072B:  MOVLW  20
072C:  MOVWF  41
072D:  BCF    03,6
072E:  CALL   6B5
....................         outnic(TCR, 0x02);                  /* Tx internal loopback */ 
072F:  MOVLW  0D
0730:  BSF    03,6
0731:  MOVWF  40
0732:  MOVLW  02
0733:  MOVWF  41
0734:  BCF    03,6
0735:  CALL   6B5
....................         outnic(TPSR, TXSTART);              /* Set Tx start page */ 
0736:  MOVLW  04
0737:  BSF    03,6
0738:  MOVWF  40
0739:  MOVLW  40
073A:  MOVWF  41
073B:  BCF    03,6
073C:  CALL   6B5
....................         outnic(PSTART, RXSTART);            /* Set Rx start, stop, boundary */ 
073D:  MOVLW  01
073E:  BSF    03,6
073F:  MOVWF  40
0740:  MOVLW  46
0741:  MOVWF  41
0742:  BCF    03,6
0743:  CALL   6B5
....................         outnic(PSTOP, RXSTOP); 
0744:  MOVLW  02
0745:  BSF    03,6
0746:  MOVWF  40
0747:  MOVLW  5F
0748:  MOVWF  41
0749:  BCF    03,6
074A:  CALL   6B5
....................         outnic(BNRY, (BYTE)(RXSTOP-1)); 
074B:  MOVLW  03
074C:  BSF    03,6
074D:  MOVWF  40
074E:  MOVLW  5E
074F:  MOVWF  41
0750:  BCF    03,6
0751:  CALL   6B5
....................         outnic(ISR, 0xff);                  /* Clear interrupt flags */ 
0752:  MOVLW  07
0753:  BSF    03,6
0754:  MOVWF  40
0755:  MOVLW  FF
0756:  MOVWF  41
0757:  BCF    03,6
0758:  CALL   6B5
....................         outnic(IMR, 0);                     /* Mask all interrupts */ 
0759:  MOVLW  0F
075A:  BSF    03,6
075B:  MOVWF  40
075C:  CLRF   41
075D:  BCF    03,6
075E:  CALL   6B5
....................         outnic(CMDR, 0x61);                 /* Stop, DMA abort, page 1 */ 
075F:  BSF    03,6
0760:  CLRF   40
0761:  MOVLW  61
0762:  MOVWF  41
0763:  BCF    03,6
0764:  CALL   6B5
....................         delay_ms(2); 
0765:  MOVLW  02
0766:  BSF    03,6
0767:  MOVWF  33
0768:  BCF    03,6
0769:  CALL   0ED
....................         for (i=0; i<6; i++)                 /* Set Phys addr */ 
076A:  BSF    03,6
076B:  CLRF   2E
076C:  BCF    03,6
076D:  MOVLW  06
076E:  BSF    03,6
076F:  SUBWF  2E,W
0770:  BTFSS  03,0
0771:  GOTO   774
0772:  BCF    03,6
0773:  GOTO   78B
0774:  BCF    03,6
....................             outnic(PAR0+i, myeth[i]); 
0775:  MOVLW  01
0776:  BSF    03,6
0777:  ADDWF  2E,W
0778:  MOVWF  30
0779:  MOVLW  2A
077A:  ADDWF  2E,W
077B:  BCF    03,6
077C:  MOVWF  04
077D:  BCF    03,7
077E:  MOVF   00,W
077F:  BSF    03,6
0780:  MOVWF  31
0781:  MOVF   30,W
0782:  MOVWF  40
0783:  MOVF   31,W
0784:  MOVWF  41
0785:  BCF    03,6
0786:  CALL   6B5
0787:  BSF    03,6
0788:  INCF   2E,F
0789:  BCF    03,6
078A:  GOTO   76D
....................         for (i=0; i<8; i++)                 /* Multicast accept-all */ 
078B:  BSF    03,6
078C:  CLRF   2E
078D:  BCF    03,6
078E:  MOVLW  08
078F:  BSF    03,6
0790:  SUBWF  2E,W
0791:  BTFSS  03,0
0792:  GOTO   795
0793:  BCF    03,6
0794:  GOTO   7A4
0795:  BCF    03,6
....................             outnic(MAR0+i, 0xff); 
0796:  MOVLW  08
0797:  BSF    03,6
0798:  ADDWF  2E,W
0799:  MOVWF  30
079A:  MOVF   30,W
079B:  MOVWF  40
079C:  MOVLW  FF
079D:  MOVWF  41
079E:  BCF    03,6
079F:  CALL   6B5
07A0:  BSF    03,6
07A1:  INCF   2E,F
07A2:  BCF    03,6
07A3:  GOTO   78E
....................         outnic(CURRP, RXSTART+1);           /* Set current Rx page */ 
07A4:  MOVLW  07
07A5:  BSF    03,6
07A6:  MOVWF  40
07A7:  MOVLW  47
07A8:  MOVWF  41
07A9:  BCF    03,6
07AA:  CALL   6B5
....................         next_page = RXSTART + 1; 
07AB:  MOVLW  47
07AC:  MOVWF  30
.................... // Set LED 0 to be a 'link' LED, not 'collision' LED 
.................... // It would be nice if the following code worked, but the upper bits of the 
.................... // RTL config3 register are obstinately read-only, so it doesn't! 
.................... //        outnic(CMDR, 0xe0);                 /* DMA abort, page 3 */ 
.................... //        outnic(RTL9346CR, 0xc0);            /* Write-enable config regs */ 
.................... //        outnic(RTL3, 0x10);                 /* Enable 'link' LED */ 
.................... //        outnic(RTL9346CR, 0x00);            /* Write-protect config regs */ 
....................         outnic(CMDR, 0x20);                 /* DMA abort, page 0 */ 
07AD:  BSF    03,6
07AE:  CLRF   40
07AF:  MOVLW  20
07B0:  MOVWF  41
07B1:  BCF    03,6
07B2:  CALL   6B5
.................... #if PROMISC 
....................         outnic(RCR, 0x14);                  /* Accept broadcasts and all packets!*/ 
.................... #else 
....................         outnic(RCR, 0x04);                  /* Accept broadcasts */ 
07B3:  MOVLW  0C
07B4:  BSF    03,6
07B5:  MOVWF  40
07B6:  MOVLW  04
07B7:  MOVWF  41
07B8:  BCF    03,6
07B9:  CALL   6B5
.................... #endif 
....................         outnic(TCR, 0);                     /* Normal Tx operation */ 
07BA:  MOVLW  0D
07BB:  BSF    03,6
07BC:  MOVWF  40
07BD:  CLRF   41
07BE:  BCF    03,6
07BF:  CALL   6B5
....................         outnic(ISR, 0xff);                  /* Clear interrupt flags */ 
07C0:  MOVLW  07
07C1:  BSF    03,6
07C2:  MOVWF  40
07C3:  MOVLW  FF
07C4:  MOVWF  41
07C5:  BCF    03,6
07C6:  CALL   6B5
....................         outnic(CMDR, 0x22);                 /* Start NIC */ 
07C7:  BSF    03,6
07C8:  CLRF   40
07C9:  MOVLW  22
07CA:  MOVWF  41
07CB:  BCF    03,6
07CC:  CALL   6B5
....................         ok = 1; 
07CD:  MOVLW  01
07CE:  BSF    03,6
07CF:  MOVWF  2D
07D0:  BCF    03,6
....................     } 
....................     return(ok); 
07D1:  BSF    03,6
07D2:  MOVF   2D,W
07D3:  BCF    03,6
07D4:  MOVWF  78
07D5:  RETLW  00
.................... } 
....................  
.................... /* Get packet into buffer, return length (excl CRC), or 0 if none available */ 
.................... WORD get_ether() 
.................... { 
....................     WORD len=0, curr; 
....................     BYTE bound;        
....................     WORD oset; 
*
08A5:  BSF    03,6
08A6:  CLRF   25
08A7:  CLRF   26
....................     int i; 
....................  
....................     if (innic(ISR) & 0x10)              /* If Rx overrun.. */ 
08A8:  MOVLW  07
08A9:  MOVWF  3F
08AA:  BCF    03,6
08AB:  BCF    0A,3
08AC:  CALL   6A2
08AD:  BSF    0A,3
08AE:  MOVF   78,W
08AF:  ANDLW  10
08B0:  IORLW  00
08B1:  BTFSC  03,2
08B2:  GOTO   0CD
....................     { 
....................         printf(" NIC Rx overrun "); 
*
0017:  BCF    0A,0
0018:  BCF    0A,1
0019:  BCF    0A,2
001A:  ADDWF  02,F
001B:  RETLW  20
001C:  RETLW  4E
001D:  RETLW  49
001E:  RETLW  43
001F:  RETLW  20
0020:  RETLW  52
0021:  RETLW  78
0022:  RETLW  20
0023:  RETLW  6F
0024:  RETLW  76
0025:  RETLW  65
0026:  RETLW  72
0027:  RETLW  72
0028:  RETLW  75
0029:  RETLW  6E
002A:  RETLW  20
002B:  RETLW  00
*
08B3:  BSF    03,6
08B4:  CLRF   2D
08B5:  BCF    03,6
08B6:  BSF    03,6
08B7:  MOVF   2D,W
08B8:  BCF    03,6
08B9:  BCF    0A,3
08BA:  CALL   017
08BB:  BSF    0A,3
08BC:  BSF    03,6
08BD:  INCF   2D,F
08BE:  BCF    03,6
08BF:  BTFSS  0C,4
08C0:  GOTO   0BF
08C1:  MOVWF  19
08C2:  MOVLW  10
08C3:  BSF    03,6
08C4:  SUBWF  2D,W
08C5:  BTFSC  03,2
08C6:  GOTO   0C9
08C7:  BCF    03,6
08C8:  GOTO   0B6
....................         init_ether();                   /* ..reset controller (drastic!) */ 
08C9:  BCF    03,6
08CA:  BCF    0A,3
08CB:  CALL   6C9
08CC:  BSF    0A,3
....................     } 
....................     outnic(CMDR, 0x60);                 /* DMA abort, page 1 */ 
08CD:  BSF    03,6
08CE:  CLRF   40
08CF:  MOVLW  60
08D0:  MOVWF  41
08D1:  BCF    03,6
08D2:  BCF    0A,3
08D3:  CALL   6B5
08D4:  BSF    0A,3
....................     curr = innic(CURRP);                /* Get current page */ 
08D5:  MOVLW  07
08D6:  BSF    03,6
08D7:  MOVWF  3F
08D8:  BCF    03,6
08D9:  BCF    0A,3
08DA:  CALL   6A2
08DB:  BSF    0A,3
08DC:  BSF    03,6
08DD:  CLRF   28
08DE:  BCF    03,6
08DF:  MOVF   78,W
08E0:  BSF    03,6
08E1:  MOVWF  27
....................     outnic(CMDR, 0x20);                 /* DMA abort, page 0 */ 
08E2:  CLRF   40
08E3:  MOVLW  20
08E4:  MOVWF  41
08E5:  BCF    03,6
08E6:  BCF    0A,3
08E7:  CALL   6B5
08E8:  BSF    0A,3
....................     if (curr != next_page)              /* If Rx packet.. */ 
08E9:  BSF    03,6
08EA:  MOVF   28,F
08EB:  BTFSC  03,2
08EC:  GOTO   0EF
08ED:  BCF    03,6
08EE:  GOTO   0F8
08EF:  BCF    03,6
08F0:  MOVF   30,W
08F1:  BSF    03,6
08F2:  SUBWF  27,W
08F3:  BTFSS  03,2
08F4:  GOTO   0F7
08F5:  BCF    03,6
08F6:  GOTO   219
08F7:  BCF    03,6
....................     { 
....................         curr_rx_page = next_page; 
08F8:  MOVF   30,W
08F9:  MOVWF  31
....................         setnic_addr((WORD)next_page<<8); 
08FA:  BSF    03,6
08FB:  CLRF   2E
08FC:  BCF    03,6
08FD:  MOVF   30,W
08FE:  BSF    03,6
08FF:  MOVWF  2D
0900:  MOVF   2D,W
0901:  MOVWF  2E
0902:  CLRF   2D
0903:  MOVF   2E,W
0904:  MOVWF  3D
0905:  MOVF   2D,W
0906:  MOVWF  3C
0907:  BCF    03,6
0908:  CALL   063
....................         getnic_data((BYTE *)&nicin, sizeof(nicin)); 
0909:  MOVLW  00
090A:  BSF    03,6
090B:  MOVWF  2E
090C:  MOVLW  32
090D:  MOVWF  2D
090E:  MOVLW  12
090F:  MOVWF  2F
....................         len = nicin.nic.len;            /* Take length from stored header */ 
*
0956:  MOVF   35,W
0957:  BSF    03,6
0958:  MOVWF  26
0959:  BCF    03,6
095A:  MOVF   34,W
095B:  BSF    03,6
095C:  MOVWF  25
....................         if ((nicin.nic.stat&1) && len>=MINFRAMEC && len<=MAXFRAMEC) 
095D:  BCF    03,6
095E:  MOVF   32,W
095F:  ANDLW  01
0960:  IORLW  00
0961:  BTFSC  03,2
0962:  GOTO   1BC
0963:  MOVLW  01
0964:  BSF    03,6
0965:  SUBWF  26,W
0966:  BTFSS  03,0
0967:  GOTO   16A
0968:  BCF    03,6
0969:  GOTO   17A
096A:  BCF    03,6
096B:  BSF    03,6
096C:  MOVF   26,F
096D:  BTFSC  03,2
096E:  GOTO   171
096F:  BCF    03,6
0970:  GOTO   1BC
0971:  BCF    03,6
0972:  MOVLW  40
0973:  BSF    03,6
0974:  SUBWF  25,W
0975:  BTFSC  03,0
0976:  GOTO   179
0977:  BCF    03,6
0978:  GOTO   1BC
0979:  BCF    03,6
097A:  MOVLW  05
097B:  BSF    03,6
097C:  SUBWF  26,W
097D:  BTFSC  03,0
097E:  GOTO   181
097F:  BCF    03,6
0980:  GOTO   192
0981:  BCF    03,6
0982:  MOVLW  05
0983:  BSF    03,6
0984:  SUBWF  26,W
0985:  BTFSC  03,2
0986:  GOTO   189
0987:  BCF    03,6
0988:  GOTO   1BC
0989:  BCF    03,6
098A:  MOVLW  EF
098B:  BSF    03,6
098C:  SUBWF  25,W
098D:  BTFSS  03,0
098E:  GOTO   191
098F:  BCF    03,6
0990:  GOTO   1BC
0991:  BCF    03,6
....................         {                               /* If hdr is OK, get packet */ 
....................             len -= MACLEN+MACLEN+2+CRCLEN; 
0992:  MOVLW  12
0993:  BSF    03,6
0994:  SUBWF  25,F
0995:  MOVLW  00
0996:  BTFSS  03,0
0997:  DECF   26,F
0998:  SUBWF  26,F
....................             rxin = len; 
0999:  MOVF   26,W
099A:  BCF    03,6
099B:  MOVWF  45
099C:  BSF    03,6
099D:  MOVF   25,W
099E:  BCF    03,6
099F:  MOVWF  44
....................             swapw(nicin.eth.pcol); 
.................... #if DEBUG 
....................             printf(" Rx%lu>", len); 
.................... #endif             
....................         } 
....................         else                            /* If not, no packet data */ 
*
09BB:  GOTO   1D5
....................         {              
....................             len = 0; 
09BC:  BSF    03,6
09BD:  CLRF   26
09BE:  CLRF   25
....................             printf(" NIC pkt err "); 
*
002C:  BCF    0A,0
002D:  BCF    0A,1
002E:  BCF    0A,2
002F:  ADDWF  02,F
0030:  RETLW  20
0031:  RETLW  4E
0032:  RETLW  49
0033:  RETLW  43
0034:  RETLW  20
0035:  RETLW  70
0036:  RETLW  6B
0037:  RETLW  74
0038:  RETLW  20
0039:  RETLW  65
003A:  RETLW  72
003B:  RETLW  72
003C:  RETLW  20
003D:  RETLW  00
*
09BF:  CLRF   2D
09C0:  BCF    03,6
09C1:  BSF    03,6
09C2:  MOVF   2D,W
09C3:  BCF    03,6
09C4:  BCF    0A,3
09C5:  CALL   02C
09C6:  BSF    0A,3
09C7:  BSF    03,6
09C8:  INCF   2D,F
09C9:  BCF    03,6
09CA:  BTFSS  0C,4
09CB:  GOTO   1CA
09CC:  MOVWF  19
09CD:  MOVLW  0D
09CE:  BSF    03,6
09CF:  SUBWF  2D,W
09D0:  BTFSC  03,2
09D1:  GOTO   1D4
09D2:  BCF    03,6
09D3:  GOTO   1C1
09D4:  BCF    03,6
....................         }                               /* Update next packet ptr */ 
....................         if (nicin.nic.next>=RXSTART && nicin.nic.next<RXSTOP) 
09D5:  MOVLW  46
09D6:  SUBWF  33,W
09D7:  BTFSS  03,0
09D8:  GOTO   1E0
09D9:  MOVLW  5F
09DA:  SUBWF  33,W
09DB:  BTFSC  03,0
09DC:  GOTO   1E0
....................             next_page = nicin.nic.next; 
09DD:  MOVF   33,W
09DE:  MOVWF  30
....................         else                            /* If invalid, use prev+1 */ 
09DF:  GOTO   205
....................         { 
....................             printf(" NIC ptr err "); 
*
003E:  BCF    0A,0
003F:  BCF    0A,1
0040:  BCF    0A,2
0041:  ADDWF  02,F
0042:  RETLW  20
0043:  RETLW  4E
0044:  RETLW  49
0045:  RETLW  43
0046:  RETLW  20
0047:  RETLW  70
0048:  RETLW  74
0049:  RETLW  72
004A:  RETLW  20
004B:  RETLW  65
004C:  RETLW  72
004D:  RETLW  72
004E:  RETLW  20
004F:  RETLW  00
*
09E0:  BSF    03,6
09E1:  CLRF   2D
09E2:  BCF    03,6
09E3:  BSF    03,6
09E4:  MOVF   2D,W
09E5:  BCF    03,6
09E6:  BCF    0A,3
09E7:  CALL   03E
09E8:  BSF    0A,3
09E9:  BSF    03,6
09EA:  INCF   2D,F
09EB:  BCF    03,6
09EC:  BTFSS  0C,4
09ED:  GOTO   1EC
09EE:  MOVWF  19
09EF:  MOVLW  0D
09F0:  BSF    03,6
09F1:  SUBWF  2D,W
09F2:  BTFSC  03,2
09F3:  GOTO   1F6
09F4:  BCF    03,6
09F5:  GOTO   1E3
....................             next_page = nicwrap(next_page + 1); 
09F6:  MOVLW  01
09F7:  BCF    03,6
09F8:  ADDWF  30,W
09F9:  BSF    03,6
09FA:  MOVWF  2D
09FB:  MOVF   2D,W
09FC:  MOVWF  2E
09FD:  BCF    03,6
09FE:  CALL   087
09FF:  MOVF   78,W
0A00:  MOVWF  30
....................             len = 0; 
0A01:  BSF    03,6
0A02:  CLRF   26
0A03:  CLRF   25
0A04:  BCF    03,6
....................         }                               /* Update boundary register */ 
....................         bound = nicwrap(next_page - 1); 
0A05:  MOVF   30,W
0A06:  BSF    03,6
0A07:  MOVWF  2D
0A08:  MOVLW  01
0A09:  SUBWF  2D,F
0A0A:  MOVF   2D,W
0A0B:  MOVWF  2E
0A0C:  BCF    03,6
0A0D:  CALL   087
0A0E:  MOVF   78,W
0A0F:  BSF    03,6
0A10:  MOVWF  29
....................         outnic(BNRY, bound); 
0A11:  MOVLW  03
0A12:  MOVWF  40
0A13:  MOVF   29,W
0A14:  MOVWF  41
0A15:  BCF    03,6
0A16:  BCF    0A,3
0A17:  CALL   6B5
0A18:  BSF    0A,3
....................     } 
....................     return(len);                        /* Return length excl. CRC */ 
0A19:  BSF    03,6
0A1A:  MOVF   25,W
0A1B:  BCF    03,6
0A1C:  MOVWF  78
0A1D:  BSF    03,6
0A1E:  MOVF   26,W
0A1F:  BCF    03,6
0A20:  MOVWF  79
0A21:  BCF    0A,3
0A22:  BSF    0A,4
0A23:  GOTO   5C2
.................... } 
....................  
.................... /* Send Ethernet packet given payload len */ 
.................... void put_ether(void *data, WORD dlen) 
.................... { 
....................     outnic(ISR, 0x0a);              /* Clear interrupt flags */ 
*
0B5E:  MOVLW  07
0B5F:  BSF    03,6
0B60:  MOVWF  40
0B61:  MOVLW  0A
0B62:  MOVWF  41
0B63:  BCF    03,6
0B64:  BCF    0A,3
0B65:  CALL   6B5
0B66:  BSF    0A,3
....................     setnic_addr(TXSTART<<8); 
0B67:  MOVLW  40
0B68:  BSF    03,6
0B69:  MOVWF  3D
0B6A:  CLRF   3C
0B6B:  BCF    03,6
0B6C:  CALL   063
....................     putnic_data(nicin.eth.srce, MACLEN); 
0B6D:  MOVLW  00
0B6E:  BSF    03,6
0B6F:  MOVWF  3D
0B70:  MOVLW  3C
0B71:  MOVWF  3C
0B72:  MOVLW  06
0B73:  MOVWF  3E
0B74:  BCF    03,6
0B75:  CALL   2FA
....................     putnic_data(myeth, MACLEN); 
0B76:  MOVLW  00
0B77:  BSF    03,6
0B78:  MOVWF  3D
0B79:  MOVLW  2A
0B7A:  MOVWF  3C
0B7B:  MOVLW  06
0B7C:  MOVWF  3E
0B7D:  BCF    03,6
0B7E:  CALL   2FA
....................     swapw(nicin.eth.pcol);          
....................     putnic_data(&nicin.eth.pcol, 2); 
*
0B9A:  MOVLW  00
0B9B:  BSF    03,6
0B9C:  MOVWF  3D
0B9D:  MOVLW  42
0B9E:  MOVWF  3C
0B9F:  MOVLW  02
0BA0:  MOVWF  3E
0BA1:  BCF    03,6
0BA2:  CALL   2FA
....................     putnic_data(data, dlen); 
0BA3:  BSF    03,6
0BA4:  MOVF   39,W
0BA5:  MOVWF  3D
0BA6:  MOVF   38,W
0BA7:  MOVWF  3C
0BA8:  MOVF   3A,W
0BA9:  MOVWF  3E
0BAA:  BCF    03,6
0BAB:  CALL   2FA
0BAC:  RETLW  00
.................... } 
....................  
.................... /* Transmit the Ethernet frame */ 
.................... void xmit_ether(WORD dlen) 
.................... { 
....................     dlen += MACLEN+MACLEN+2; 
0BAD:  MOVLW  0E
0BAE:  BSF    03,6
0BAF:  ADDWF  38,F
0BB0:  MOVLW  00
0BB1:  BTFSC  03,0
0BB2:  ADDLW  01
0BB3:  ADDWF  39,F
0BB4:  BCF    03,6
....................     if (dlen < MINFRAME) 
0BB5:  BSF    03,6
0BB6:  MOVF   39,F
0BB7:  BTFSC  03,2
0BB8:  GOTO   3BB
0BB9:  BCF    03,6
0BBA:  GOTO   3C9
0BBB:  BCF    03,6
0BBC:  MOVLW  3C
0BBD:  BSF    03,6
0BBE:  SUBWF  38,W
0BBF:  BTFSS  03,0
0BC0:  GOTO   3C3
0BC1:  BCF    03,6
0BC2:  GOTO   3C9
0BC3:  BCF    03,6
....................         dlen = MINFRAME;            /* Constrain length */ 
0BC4:  BSF    03,6
0BC5:  CLRF   39
0BC6:  MOVLW  3C
0BC7:  MOVWF  38
0BC8:  BCF    03,6
....................     outnic(TBCR0, dlen);            /* Set Tx length regs */ 
0BC9:  MOVLW  05
0BCA:  BSF    03,6
0BCB:  MOVWF  40
0BCC:  MOVF   38,W
0BCD:  MOVWF  41
0BCE:  BCF    03,6
0BCF:  BCF    0A,3
0BD0:  CALL   6B5
0BD1:  BSF    0A,3
....................     outnic(TBCR1, dlen >> 8);                                   
0BD2:  BSF    03,6
0BD3:  MOVF   39,W
0BD4:  MOVWF  3A
0BD5:  CLRF   3B
0BD6:  MOVLW  06
0BD7:  MOVWF  40
0BD8:  MOVF   3A,W
0BD9:  MOVWF  41
0BDA:  BCF    03,6
0BDB:  BCF    0A,3
0BDC:  CALL   6B5
0BDD:  BSF    0A,3
....................     outnic(CMDR, 0x24);             /* Transmit the packet */ 
0BDE:  BSF    03,6
0BDF:  CLRF   40
0BE0:  MOVLW  24
0BE1:  MOVWF  41
0BE2:  BCF    03,6
0BE3:  BCF    0A,3
0BE4:  CALL   6B5
0BE5:  BSF    0A,3
0BE6:  RETLW  00
.................... } 
....................  
.................... /* Copy a block from NIC Rx to Tx buffers (not crossing page boundaries) */ 
.................... void copy_rx_tx(BYTE dest, BYTE srce, BYTE len) 
.................... {        
....................     BYTE b; 
....................      
....................     outnic(ISR, 0x40);                  /* Clear remote DMA interrupt flag */ 
*
1966:  MOVLW  07
1967:  MOVWF  40
1968:  MOVLW  40
1969:  MOVWF  41
196A:  BCF    03,6
196B:  BCF    0A,4
196C:  BCF    0A,3
196D:  CALL   6B5
196E:  BSF    0A,4
196F:  BSF    0A,3
....................     dest += sizeof(ETHERHEADER); 
1970:  MOVLW  0E
1971:  BSF    03,6
1972:  ADDWF  2D,F
....................     srce += sizeof(NICETHERHEADER); 
1973:  MOVLW  12
1974:  ADDWF  2E,F
1975:  BCF    03,6
....................     while (len--) 
1976:  BSF    03,6
1977:  MOVF   2F,W
1978:  DECF   2F,F
1979:  IORLW  00
197A:  BTFSS  03,2
197B:  GOTO   17E
197C:  BCF    03,6
197D:  GOTO   1BE
197E:  BCF    03,6
....................     { 
....................         outnic(RSAR0, srce); 
197F:  MOVLW  08
1980:  BSF    03,6
1981:  MOVWF  40
1982:  MOVF   2E,W
1983:  MOVWF  41
1984:  BCF    03,6
1985:  BCF    0A,4
1986:  BCF    0A,3
1987:  CALL   6B5
1988:  BSF    0A,4
1989:  BSF    0A,3
....................         outnic(RSAR1, curr_rx_page); 
198A:  MOVLW  09
198B:  BSF    03,6
198C:  MOVWF  40
198D:  BCF    03,6
198E:  MOVF   31,W
198F:  BSF    03,6
1990:  MOVWF  41
1991:  BCF    03,6
1992:  BCF    0A,4
1993:  BCF    0A,3
1994:  CALL   6B5
1995:  BSF    0A,4
1996:  BSF    0A,3
....................         b = getnic_byte(); 
1997:  BCF    0A,4
1998:  CALL   224
1999:  BSF    0A,4
199A:  MOVF   78,W
199B:  BSF    03,6
199C:  MOVWF  30
....................         outnic(RSAR0, dest); 
199D:  MOVLW  08
199E:  MOVWF  40
199F:  MOVF   2D,W
19A0:  MOVWF  41
19A1:  BCF    03,6
19A2:  BCF    0A,4
19A3:  BCF    0A,3
19A4:  CALL   6B5
19A5:  BSF    0A,4
19A6:  BSF    0A,3
....................         outnic(RSAR1, TXSTART); 
19A7:  MOVLW  09
19A8:  BSF    03,6
19A9:  MOVWF  40
19AA:  MOVLW  40
19AB:  MOVWF  41
19AC:  BCF    03,6
19AD:  BCF    0A,4
19AE:  BCF    0A,3
19AF:  CALL   6B5
19B0:  BSF    0A,4
19B1:  BSF    0A,3
....................         putnic_byte(b); 
19B2:  BSF    03,6
19B3:  MOVF   30,W
19B4:  MOVWF  3E
19B5:  BCF    03,6
19B6:  BCF    0A,4
19B7:  CALL   5B7
19B8:  BSF    0A,4
....................         srce++; 
19B9:  BSF    03,6
19BA:  INCF   2E,F
....................         dest++; 
19BB:  INCF   2D,F
....................     } 
19BC:  BCF    03,6
19BD:  GOTO   176
.................... } 
....................  
.................... /* Checksum the given number of bytes in the Rx NIC buffer */ 
.................... void check_rxbytes(BYTE oset, WORD len) 
.................... {        
....................     BYTE b; 
....................   
....................     outnic(ISR, 0x40);                  /* Clear remote DMA interrupt flag */ 
*
1B6E:  MOVLW  07
1B6F:  MOVWF  40
1B70:  MOVLW  40
1B71:  MOVWF  41
1B72:  BCF    03,6
1B73:  BCF    0A,4
1B74:  BCF    0A,3
1B75:  CALL   6B5
1B76:  BSF    0A,4
1B77:  BSF    0A,3
....................     outnic(RBCR0, len);                 /* Byte count */ 
1B78:  MOVLW  0A
1B79:  BSF    03,6
1B7A:  MOVWF  40
1B7B:  MOVF   32,W
1B7C:  MOVWF  41
1B7D:  BCF    03,6
1B7E:  BCF    0A,4
1B7F:  BCF    0A,3
1B80:  CALL   6B5
1B81:  BSF    0A,4
1B82:  BSF    0A,3
....................     outnic(RBCR1, len>>8); 
1B83:  BSF    03,6
1B84:  MOVF   33,W
1B85:  MOVWF  35
1B86:  CLRF   36
1B87:  MOVLW  0B
1B88:  MOVWF  40
1B89:  MOVF   35,W
1B8A:  MOVWF  41
1B8B:  BCF    03,6
1B8C:  BCF    0A,4
1B8D:  BCF    0A,3
1B8E:  CALL   6B5
1B8F:  BSF    0A,4
1B90:  BSF    0A,3
....................     outnic(CMDR, 0x0a);                 /* Start, DMA remote read */ 
1B91:  BSF    03,6
1B92:  CLRF   40
1B93:  MOVLW  0A
1B94:  MOVWF  41
1B95:  BCF    03,6
1B96:  BCF    0A,4
1B97:  BCF    0A,3
1B98:  CALL   6B5
1B99:  BSF    0A,4
1B9A:  BSF    0A,3
....................     while (len--)                       /* Get bytes */ 
1B9B:  BSF    03,6
1B9C:  MOVF   33,W
1B9D:  BCF    03,6
1B9E:  MOVWF  7A
1B9F:  BSF    03,6
1BA0:  MOVF   32,W
1BA1:  BTFSC  03,2
1BA2:  DECF   33,F
1BA3:  DECF   32,F
1BA4:  BCF    03,6
1BA5:  IORWF  7A,W
1BA6:  BTFSC  03,2
1BA7:  GOTO   3BB
....................     { 
....................         b = innic(DATAPORT); 
1BA8:  MOVLW  10
1BA9:  BSF    03,6
1BAA:  MOVWF  3F
1BAB:  BCF    03,6
1BAC:  BCF    0A,4
1BAD:  BCF    0A,3
1BAE:  CALL   6A2
1BAF:  BSF    0A,4
1BB0:  BSF    0A,3
1BB1:  MOVF   78,W
1BB2:  BSF    03,6
1BB3:  MOVWF  34
....................         check_byte(b); 
1BB4:  MOVF   34,W
1BB5:  MOVWF  3E
1BB6:  BCF    03,6
1BB7:  BCF    0A,4
1BB8:  CALL   249
1BB9:  BSF    0A,4
....................     } 
1BBA:  GOTO   39B
.................... }     
....................  
.................... /* Set the 'remote DMA' address in the NIC's RAM to be accessed */ 
.................... void setnic_addr(WORD addr) 
.................... { 
....................     outnic(ISR, 0x40);                  /* Clear remote DMA interrupt flag */ 
*
0863:  MOVLW  07
0864:  BSF    03,6
0865:  MOVWF  40
0866:  MOVLW  40
0867:  MOVWF  41
0868:  BCF    03,6
0869:  BCF    0A,3
086A:  CALL   6B5
086B:  BSF    0A,3
....................     outnic(RSAR0, addr&0xff);           /* Data addr */ 
086C:  BSF    03,6
086D:  MOVF   3D,W
086E:  ANDLW  00
086F:  MOVWF  3F
0870:  MOVF   3C,W
0871:  MOVWF  3E
0872:  MOVLW  08
0873:  MOVWF  40
0874:  MOVF   3E,W
0875:  MOVWF  41
0876:  BCF    03,6
0877:  BCF    0A,3
0878:  CALL   6B5
0879:  BSF    0A,3
....................     outnic(RSAR1, addr>>8); 
087A:  BSF    03,6
087B:  MOVF   3D,W
087C:  MOVWF  3E
087D:  CLRF   3F
087E:  MOVLW  09
087F:  MOVWF  40
0880:  MOVF   3E,W
0881:  MOVWF  41
0882:  BCF    03,6
0883:  BCF    0A,3
0884:  CALL   6B5
0885:  BSF    0A,3
0886:  RETLW  00
.................... } 
....................  
.................... /* Get the 'remote DMA' address in the NIC's RAM to be accessed */ 
.................... WORD getnic_addr(void) 
.................... {       
....................     WORD addr;     
....................      
....................     addr = innic(RSAR0) + ((WORD)innic(RSAR1) << 8); 
*
1B25:  MOVLW  08
1B26:  BSF    03,6
1B27:  MOVWF  3F
1B28:  BCF    03,6
1B29:  BCF    0A,4
1B2A:  BCF    0A,3
1B2B:  CALL   6A2
1B2C:  BSF    0A,4
1B2D:  BSF    0A,3
1B2E:  MOVF   78,W
1B2F:  BSF    03,6
1B30:  MOVWF  31
1B31:  MOVLW  09
1B32:  MOVWF  3F
1B33:  BCF    03,6
1B34:  BCF    0A,4
1B35:  BCF    0A,3
1B36:  CALL   6A2
1B37:  BSF    0A,4
1B38:  BSF    0A,3
1B39:  BSF    03,6
1B3A:  CLRF   33
1B3B:  BCF    03,6
1B3C:  MOVF   78,W
1B3D:  BSF    03,6
1B3E:  MOVWF  32
1B3F:  MOVF   32,W
1B40:  BCF    03,6
1B41:  MOVWF  7A
1B42:  CLRW
1B43:  BSF    03,6
1B44:  ADDWF  31,W
1B45:  MOVWF  2F
1B46:  BCF    03,6
1B47:  MOVF   7A,W
1B48:  BSF    03,6
1B49:  MOVWF  30
1B4A:  BTFSC  03,0
1B4B:  INCF   30,F
....................     return(addr); 
1B4C:  MOVF   2F,W
1B4D:  BCF    03,6
1B4E:  MOVWF  78
1B4F:  BSF    03,6
1B50:  MOVF   30,W
1B51:  BCF    03,6
1B52:  MOVWF  79
.................... } 
....................  
.................... /* Return a byte from the NIC RAM */ 
.................... BYTE getnic_byte(void) 
.................... { 
....................     BYTE b; 
....................      
....................     outnic(RBCR0, 1);                   /* Byte count */ 
*
0A24:  MOVLW  0A
0A25:  BSF    03,6
0A26:  MOVWF  40
0A27:  MOVLW  01
0A28:  MOVWF  41
0A29:  BCF    03,6
0A2A:  BCF    0A,3
0A2B:  CALL   6B5
0A2C:  BSF    0A,3
....................     outnic(RBCR1, 0); 
0A2D:  MOVLW  0B
0A2E:  BSF    03,6
0A2F:  MOVWF  40
0A30:  CLRF   41
0A31:  BCF    03,6
0A32:  BCF    0A,3
0A33:  CALL   6B5
0A34:  BSF    0A,3
....................     outnic(CMDR, 0x0a);                 /* Start, DMA remote read */ 
0A35:  BSF    03,6
0A36:  CLRF   40
0A37:  MOVLW  0A
0A38:  MOVWF  41
0A39:  BCF    03,6
0A3A:  BCF    0A,3
0A3B:  CALL   6B5
0A3C:  BSF    0A,3
....................     b = innic(DATAPORT); 
0A3D:  MOVLW  10
0A3E:  BSF    03,6
0A3F:  MOVWF  3F
0A40:  BCF    03,6
0A41:  BCF    0A,3
0A42:  CALL   6A2
0A43:  BSF    0A,3
0A44:  MOVF   78,W
0A45:  BSF    03,6
0A46:  MOVWF  38
0A47:  BCF    03,6
0A48:  RETLW  00
.................... } 
....................  
.................... /* Get data from NIC's RAM into the given buffer */ 
.................... void getnic_data(BYTE *data, int len) 
.................... { 
....................     BYTE b; 
....................      
....................     outnic(ISR, 0x40);                  /* Clear remote DMA interrupt flag */ 
*
0910:  MOVLW  07
0911:  MOVWF  40
0912:  MOVLW  40
0913:  MOVWF  41
0914:  BCF    03,6
0915:  BCF    0A,3
0916:  CALL   6B5
0917:  BSF    0A,3
....................     outnic(RBCR0, len);                 /* Byte count */ 
0918:  MOVLW  0A
0919:  BSF    03,6
091A:  MOVWF  40
091B:  MOVF   2F,W
091C:  MOVWF  41
091D:  BCF    03,6
091E:  BCF    0A,3
091F:  CALL   6B5
0920:  BSF    0A,3
....................     outnic(RBCR1, 0); 
0921:  MOVLW  0B
0922:  BSF    03,6
0923:  MOVWF  40
0924:  CLRF   41
0925:  BCF    03,6
0926:  BCF    0A,3
0927:  CALL   6B5
0928:  BSF    0A,3
....................     outnic(CMDR, 0x0a);                 /* Start, DMA remote read */ 
0929:  BSF    03,6
092A:  CLRF   40
092B:  MOVLW  0A
092C:  MOVWF  41
092D:  BCF    03,6
092E:  BCF    0A,3
092F:  CALL   6B5
0930:  BSF    0A,3
....................     while (len--)                       /* Get bytes */ 
0931:  BSF    03,6
0932:  MOVF   2F,W
0933:  DECF   2F,F
0934:  IORLW  00
0935:  BTFSS  03,2
0936:  GOTO   139
0937:  BCF    03,6
0938:  GOTO   156
0939:  BCF    03,6
....................     { 
....................         b = innic(DATAPORT); 
093A:  MOVLW  10
093B:  BSF    03,6
093C:  MOVWF  3F
093D:  BCF    03,6
093E:  BCF    0A,3
093F:  CALL   6A2
0940:  BSF    0A,3
0941:  MOVF   78,W
0942:  BSF    03,6
0943:  MOVWF  30
....................         *data++ = b; 
0944:  MOVF   2E,W
0945:  BCF    03,6
0946:  MOVWF  7A
0947:  BSF    03,6
0948:  MOVF   2D,W
0949:  INCF   2D,F
094A:  BTFSC  03,2
094B:  INCF   2E,F
094C:  MOVWF  04
094D:  BCF    03,7
094E:  BCF    03,6
094F:  BTFSC  7A,0
0950:  BSF    03,7
0951:  BSF    03,6
0952:  MOVF   30,W
0953:  MOVWF  00
....................     } 
0954:  BCF    03,6
0955:  GOTO   131
.................... } 
....................  
.................... /* Put the given byte into the NIC's RAM */ 
.................... void putnic_byte(BYTE b) 
.................... { 
....................     outnic(RBCR0, 1);                   /* Byte count */ 
*
0DB7:  MOVLW  0A
0DB8:  BSF    03,6
0DB9:  MOVWF  40
0DBA:  MOVLW  01
0DBB:  MOVWF  41
0DBC:  BCF    03,6
0DBD:  BCF    0A,3
0DBE:  CALL   6B5
0DBF:  BSF    0A,3
....................     outnic(RBCR1, 0); 
0DC0:  MOVLW  0B
0DC1:  BSF    03,6
0DC2:  MOVWF  40
0DC3:  CLRF   41
0DC4:  BCF    03,6
0DC5:  BCF    0A,3
0DC6:  CALL   6B5
0DC7:  BSF    0A,3
....................     outnic(CMDR, 0x12);                 /* Start, DMA remote write */ 
0DC8:  BSF    03,6
0DC9:  CLRF   40
0DCA:  MOVLW  12
0DCB:  MOVWF  41
0DCC:  BCF    03,6
0DCD:  BCF    0A,3
0DCE:  CALL   6B5
0DCF:  BSF    0A,3
....................     outnic(DATAPORT, b); 
0DD0:  MOVLW  10
0DD1:  BSF    03,6
0DD2:  MOVWF  40
0DD3:  MOVF   3E,W
0DD4:  MOVWF  41
0DD5:  BCF    03,6
0DD6:  BCF    0A,3
0DD7:  CALL   6B5
0DD8:  BSF    0A,3
0DD9:  RETLW  00
.................... } 
....................  
.................... /* Put the given byte into the NIC's RAM */ 
.................... void putnic_checkbyte(BYTE b) 
.................... { 
....................     check_byte(b); 
*
0F35:  BSF    03,6
0F36:  MOVF   3D,W
0F37:  MOVWF  3E
0F38:  BCF    03,6
0F39:  CALL   249
....................     putnic_byte(b); 
0F3A:  BSF    03,6
0F3B:  MOVF   3D,W
0F3C:  MOVWF  3E
0F3D:  BCF    03,6
0F3E:  CALL   5B7
....................     tpxdlen++; 
0F3F:  INCF   28,F
0F40:  BTFSC  03,2
0F41:  INCF   29,F
0F42:  RETLW  00
.................... } 
....................  
.................... /* Put the given data into the NIC's RAM */ 
.................... void putnic_data(BYTE *data, int len) 
.................... { 
....................     len += len & 1;                     /* Round length up to an even value */ 
*
0AFA:  BSF    03,6
0AFB:  MOVF   3E,W
0AFC:  ANDLW  01
0AFD:  ADDWF  3E,F
....................     outnic(ISR, 0x40);                  /* Clear remote DMA interrupt flag */ 
0AFE:  MOVLW  07
0AFF:  MOVWF  40
0B00:  MOVLW  40
0B01:  MOVWF  41
0B02:  BCF    03,6
0B03:  BCF    0A,3
0B04:  CALL   6B5
0B05:  BSF    0A,3
....................     outnic(RBCR0, len);                 /* Byte count */ 
0B06:  MOVLW  0A
0B07:  BSF    03,6
0B08:  MOVWF  40
0B09:  MOVF   3E,W
0B0A:  MOVWF  41
0B0B:  BCF    03,6
0B0C:  BCF    0A,3
0B0D:  CALL   6B5
0B0E:  BSF    0A,3
....................     outnic(RBCR1, 0); 
0B0F:  MOVLW  0B
0B10:  BSF    03,6
0B11:  MOVWF  40
0B12:  CLRF   41
0B13:  BCF    03,6
0B14:  BCF    0A,3
0B15:  CALL   6B5
0B16:  BSF    0A,3
....................     outnic(CMDR, 0x12);                 /* Start, DMA remote write */ 
0B17:  BSF    03,6
0B18:  CLRF   40
0B19:  MOVLW  12
0B1A:  MOVWF  41
0B1B:  BCF    03,6
0B1C:  BCF    0A,3
0B1D:  CALL   6B5
0B1E:  BSF    0A,3
....................     while (len--)                        /* O/P bytes */ 
0B1F:  BSF    03,6
0B20:  MOVF   3E,W
0B21:  DECF   3E,F
0B22:  IORLW  00
0B23:  BTFSS  03,2
0B24:  GOTO   327
0B25:  BCF    03,6
0B26:  GOTO   342
0B27:  BCF    03,6
....................         outnic(DATAPORT, *data++); 
0B28:  BSF    03,6
0B29:  MOVF   3D,W
0B2A:  BCF    03,6
0B2B:  MOVWF  7A
0B2C:  BSF    03,6
0B2D:  MOVF   3C,W
0B2E:  INCF   3C,F
0B2F:  BTFSC  03,2
0B30:  INCF   3D,F
0B31:  MOVWF  04
0B32:  BCF    03,7
0B33:  BCF    03,6
0B34:  BTFSC  7A,0
0B35:  BSF    03,7
0B36:  MOVF   00,W
0B37:  BSF    03,6
0B38:  MOVWF  3F
0B39:  MOVLW  10
0B3A:  MOVWF  40
0B3B:  MOVF   3F,W
0B3C:  MOVWF  41
0B3D:  BCF    03,6
0B3E:  BCF    0A,3
0B3F:  CALL   6B5
0B40:  BSF    0A,3
0B41:  GOTO   31F
....................     len = 255;                          /* Done: must ensure DMA complete */ 
0B42:  MOVLW  FF
0B43:  BSF    03,6
0B44:  MOVWF  3E
0B45:  BCF    03,6
....................     while (len && (innic(ISR)&0x40)==0) 
0B46:  BSF    03,6
0B47:  MOVF   3E,F
0B48:  BTFSS  03,2
0B49:  GOTO   34C
0B4A:  BCF    03,6
0B4B:  GOTO   35D
0B4C:  BCF    03,6
0B4D:  MOVLW  07
0B4E:  BSF    03,6
0B4F:  MOVWF  3F
0B50:  BCF    03,6
0B51:  BCF    0A,3
0B52:  CALL   6A2
0B53:  BSF    0A,3
0B54:  MOVF   78,W
0B55:  ANDLW  40
0B56:  IORLW  00
0B57:  BTFSS  03,2
0B58:  GOTO   35D
....................         len--; 
0B59:  BSF    03,6
0B5A:  DECF   3E,F
0B5B:  BCF    03,6
0B5C:  GOTO   346
0B5D:  RETLW  00
.................... } 
....................  
.................... /* Wrap an NIC Rx page number */ 
.................... BYTE nicwrap(int page) 
.................... { 
....................    if (page >= RXSTOP) 
*
0887:  MOVLW  5F
0888:  BSF    03,6
0889:  SUBWF  2E,W
088A:  BTFSC  03,0
088B:  GOTO   08E
088C:  BCF    03,6
088D:  GOTO   094
088E:  BCF    03,6
....................        page += RXSTART - RXSTOP; 
088F:  MOVLW  E7
0890:  BSF    03,6
0891:  ADDWF  2E,F
....................    else if (page < RXSTART) 
0892:  BCF    03,6
0893:  GOTO   0A0
0894:  MOVLW  46
0895:  BSF    03,6
0896:  SUBWF  2E,W
0897:  BTFSS  03,0
0898:  GOTO   09B
0899:  BCF    03,6
089A:  GOTO   0A0
089B:  BCF    03,6
....................        page += RXSTOP - RXSTART; 
089C:  MOVLW  19
089D:  BSF    03,6
089E:  ADDWF  2E,F
089F:  BCF    03,6
....................    return(page); 
08A0:  BSF    03,6
08A1:  MOVF   2E,W
08A2:  BCF    03,6
08A3:  MOVWF  78
08A4:  RETLW  00
.................... } 
....................  
.................... /* Input a byte from a NIC register */ 
.................... BYTE innic(int reg) 
.................... { 
....................     BYTE b; 
....................  
....................     DATA_FROM_NIC; 
*
06A2:  MOVLW  FF
06A3:  BSF    03,5
06A4:  MOVWF  08
....................     NIC_ADDR = reg; 
06A5:  BCF    03,5
06A6:  BSF    03,6
06A7:  MOVF   3F,W
06A8:  BCF    03,6
06A9:  MOVWF  06
....................     NIC_IOR_ = 0; 
06AA:  BCF    09,0
....................     b = NIC_DATA; 
06AB:  MOVF   08,W
06AC:  BSF    03,6
06AD:  MOVWF  40
....................     NIC_IOR_ = 1; 
06AE:  BCF    03,6
06AF:  BSF    09,0
....................     return(b); 
06B0:  BSF    03,6
06B1:  MOVF   40,W
06B2:  BCF    03,6
06B3:  MOVWF  78
06B4:  RETLW  00
.................... } 
....................  
.................... /* Output a byte to a NIC register */ 
.................... void outnic(int reg, int b) 
.................... { 
....................     NIC_ADDR = reg; 
06B5:  BSF    03,6
06B6:  MOVF   40,W
06B7:  BCF    03,6
06B8:  MOVWF  06
....................     NIC_DATA = b; 
06B9:  BSF    03,6
06BA:  MOVF   41,W
06BB:  BCF    03,6
06BC:  MOVWF  08
....................     DATA_TO_NIC; 
06BD:  MOVLW  00
06BE:  BSF    03,5
06BF:  MOVWF  08
....................     NIC_IOW_ = 0; 
06C0:  BCF    03,5
06C1:  BCF    09,1
....................     delay_cycles(1); 
06C2:  NOP
....................     NIC_IOW_ = 1; 
06C3:  BSF    09,1
....................     DATA_FROM_NIC; 
06C4:  MOVLW  FF
06C5:  BSF    03,5
06C6:  MOVWF  08
06C7:  BCF    03,5
06C8:  RETLW  00
.................... } 
....................  
.................... /* EOF */ 
.................... 
.................... #include "\chipweb\pcm\p16_drv.h" 
....................  /* Low-level driver functions for PIC Web server  
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
....................  
.................... /* Revisions: 
.................... ** v0.01 JPB 17/12/00 Functions extracted from PIC_SLIP v0.01 
.................... */ 
....................  
.................... /* Globals */ 
.................... BOOL checkflag;             // Checksum flag & byte values 
.................... BYTE checkhi, checklo; 
....................  
.................... BYTE ungot_byte; 
.................... BOOL ungot; 
....................  
.................... /* Prototypes for this file */ 
.................... int get_data(BYTE *ptr, int maxlen); 
.................... BOOL get_byte(BYTE &b); 
.................... void unget_byte(BYTE &b); 
.................... BOOL get_word(WORD &w); 
.................... BOOL get_lword(LWORD &lw); 
.................... void discard_data(void); 
.................... BOOL match_byte(BYTE b); 
.................... BOOL match_word(WORD w); 
.................... void skip_space(void); 
.................... BOOL skip_byte(); 
.................... BOOL skip_word(); 
.................... BOOL skip_lword(); 
.................... int check_str(char *s); 
.................... void check_byte(BYTE b); 
.................... void check_word(WORD w); 
.................... void check_lword(LWORD &lw); 
.................... void check_bytes(BYTE *dat, int len); 
.................... void put_byte(BYTE b); 
.................... void put_str(char *s); 
.................... void put_word(WORD w); 
.................... void put_data(BYTE *data, int len); 
.................... void put_lword(LWORD &lw); 
.................... void swapw(WORD &val); 
....................  
.................... /* Get incoming data in buffer; discard any buffer overflow */ 
.................... int get_data(BYTE *ptr, int maxlen) 
.................... { 
....................     BYTE b; 
....................     int n=0; 
....................  
....................     while (maxlen-- > 0 && get_byte(b)) 
....................     { 
....................         *ptr++ = b; 
....................         n++; 
....................     } 
....................     discard_data(); 
....................     return(n); 
.................... } 
....................  
.................... /* Discard incoming data */ 
.................... void discard_data(void) 
.................... { 
....................     while (!atend) 
*
0BE7:  BTFSC  26,1
0BE8:  GOTO   3EB
....................         getch_net(); 
0BE9:  CALL   269
0BEA:  GOTO   3E7
0BEB:  RETLW  00
.................... } 
....................  
.................... /* Get an incoming byte value, return 0 if end of message */ 
.................... BOOL get_byte(BYTE &b) 
.................... { 
....................     if (ungot) 
*
1258:  BTFSS  26,3
1259:  GOTO   25F
*
1854:  BTFSS  26,3
1855:  GOTO   059
*
1A6C:  BTFSS  26,3
1A6D:  GOTO   273
*
1A82:  BTFSS  26,3
1A83:  GOTO   287
....................         b = ungot_byte; 
*
125A:  MOVF   4C,W
125B:  BSF    03,6
125C:  MOVWF  33
*
1856:  MOVF   4C,W
1857:  MOVWF  4D
*
1A6E:  MOVF   4C,W
1A6F:  BSF    03,6
1A70:  MOVWF  2A
*
1A84:  MOVF   4C,W
1A85:  MOVWF  68
....................     else 
*
125D:  BCF    03,6
125E:  GOTO   268
*
1858:  GOTO   05E
*
1A71:  BCF    03,6
1A72:  GOTO   27A
*
1A86:  GOTO   28C
....................         b = getch_net(); 
*
125F:  BCF    0A,4
1260:  BSF    0A,3
1261:  CALL   269
1262:  BSF    0A,4
1263:  BCF    0A,3
1264:  MOVF   78,W
1265:  BSF    03,6
1266:  MOVWF  33
1267:  BCF    03,6
*
1859:  BCF    0A,4
185A:  CALL   269
185B:  BSF    0A,4
185C:  MOVF   78,W
185D:  MOVWF  4D
*
1A73:  BCF    0A,4
1A74:  CALL   269
1A75:  BSF    0A,4
1A76:  MOVF   78,W
1A77:  BSF    03,6
1A78:  MOVWF  2A
1A79:  BCF    03,6
*
1A87:  BCF    0A,4
1A88:  CALL   269
1A89:  BSF    0A,4
1A8A:  MOVF   78,W
1A8B:  MOVWF  68
....................     ungot = 0; 
*
1268:  BCF    26,3
*
185E:  BCF    26,3
*
1A7A:  BCF    26,3
*
1A8C:  BCF    26,3
....................     return(!atend); 
*
1269:  MOVLW  00
126A:  BTFSS  26,1
126B:  MOVLW  01
126C:  MOVWF  78
*
185F:  MOVLW  00
1860:  BTFSS  26,1
1861:  MOVLW  01
1862:  MOVWF  78
*
1A7B:  MOVLW  00
1A7C:  BTFSS  26,1
1A7D:  MOVLW  01
1A7E:  MOVWF  78
*
1A8D:  MOVLW  00
1A8E:  BTFSS  26,1
1A8F:  MOVLW  01
1A90:  MOVWF  78
.................... } 
....................  
.................... /* Unget (push back) an incoming byte value */ 
.................... void unget_byte(BYTE &b) 
.................... { 
....................     ungot_byte = b; 
....................     ungot = 1; 
.................... } 
....................  
.................... /* Get an incoming word value, return 0 if end of message */ 
.................... BOOL get_word(WORD &w) 
.................... { 
....................     BYTE hi, lo; 
....................  
....................     hi = getch_net(); 
*
0C1F:  BCF    03,6
0C20:  CALL   269
0C21:  MOVF   78,W
0C22:  BSF    03,6
0C23:  MOVWF  2F
*
1818:  BCF    0A,4
1819:  CALL   269
181A:  BSF    0A,4
181B:  MOVF   78,W
181C:  BSF    03,6
181D:  MOVWF  2F
*
18D8:  BCF    0A,4
18D9:  CALL   269
18DA:  BSF    0A,4
18DB:  MOVF   78,W
18DC:  BSF    03,6
18DD:  MOVWF  2F
*
19E2:  BCF    0A,4
19E3:  CALL   269
19E4:  BSF    0A,4
19E5:  MOVF   78,W
19E6:  BSF    03,6
19E7:  MOVWF  2F
*
1A0C:  BCF    0A,4
1A0D:  CALL   269
1A0E:  BSF    0A,4
1A0F:  MOVF   78,W
1A10:  BSF    03,6
1A11:  MOVWF  2F
....................     lo = getch_net(); 
*
0C24:  BCF    03,6
0C25:  CALL   269
0C26:  MOVF   78,W
0C27:  BSF    03,6
0C28:  MOVWF  30
*
181E:  BCF    03,6
181F:  BCF    0A,4
1820:  CALL   269
1821:  BSF    0A,4
1822:  MOVF   78,W
1823:  BSF    03,6
1824:  MOVWF  30
*
18DE:  BCF    03,6
18DF:  BCF    0A,4
18E0:  CALL   269
18E1:  BSF    0A,4
18E2:  MOVF   78,W
18E3:  BSF    03,6
18E4:  MOVWF  30
*
19E8:  BCF    03,6
19E9:  BCF    0A,4
19EA:  CALL   269
19EB:  BSF    0A,4
19EC:  MOVF   78,W
19ED:  BSF    03,6
19EE:  MOVWF  30
*
1A12:  BCF    03,6
1A13:  BCF    0A,4
1A14:  CALL   269
1A15:  BSF    0A,4
1A16:  MOVF   78,W
1A17:  BSF    03,6
1A18:  MOVWF  30
....................     w = ((WORD)hi<<8) | (WORD)lo; 
*
0C29:  CLRF   32
0C2A:  MOVF   2F,W
0C2B:  MOVWF  31
0C2C:  MOVF   31,W
0C2D:  MOVWF  32
0C2E:  CLRF   31
0C2F:  BCF    03,6
0C30:  CLRF   7A
0C31:  BSF    03,6
0C32:  MOVF   30,W
0C33:  BCF    03,6
0C34:  MOVWF  77
0C35:  MOVF   7A,W
0C36:  BSF    03,6
0C37:  IORWF  32,W
0C38:  MOVWF  29
0C39:  BCF    03,6
0C3A:  MOVF   77,W
0C3B:  BSF    03,6
0C3C:  IORWF  31,W
0C3D:  MOVWF  28
*
1825:  CLRF   32
1826:  MOVF   2F,W
1827:  MOVWF  31
1828:  MOVF   31,W
1829:  MOVWF  32
182A:  CLRF   31
182B:  BCF    03,6
182C:  CLRF   7A
182D:  BSF    03,6
182E:  MOVF   30,W
182F:  BCF    03,6
1830:  MOVWF  77
1831:  MOVF   7A,W
1832:  BSF    03,6
1833:  IORWF  32,W
1834:  BCF    03,6
1835:  MOVWF  6F
1836:  MOVF   77,W
1837:  BSF    03,6
1838:  IORWF  31,W
1839:  BCF    03,6
183A:  MOVWF  6E
*
18E5:  CLRF   32
18E6:  MOVF   2F,W
18E7:  MOVWF  31
18E8:  MOVF   31,W
18E9:  MOVWF  32
18EA:  CLRF   31
18EB:  BCF    03,6
18EC:  CLRF   7A
18ED:  BSF    03,6
18EE:  MOVF   30,W
18EF:  BCF    03,6
18F0:  MOVWF  77
18F1:  MOVF   7A,W
18F2:  BSF    03,6
18F3:  IORWF  32,W
18F4:  MOVWF  2C
18F5:  BCF    03,6
18F6:  MOVF   77,W
18F7:  BSF    03,6
18F8:  IORWF  31,W
18F9:  MOVWF  2B
*
19EF:  CLRF   32
19F0:  MOVF   2F,W
19F1:  MOVWF  31
19F2:  MOVF   31,W
19F3:  MOVWF  32
19F4:  CLRF   31
19F5:  BCF    03,6
19F6:  CLRF   7A
19F7:  BSF    03,6
19F8:  MOVF   30,W
19F9:  BCF    03,6
19FA:  MOVWF  77
19FB:  MOVF   7A,W
19FC:  BSF    03,6
19FD:  IORWF  32,W
19FE:  BCF    03,6
19FF:  MOVWF  5D
1A00:  MOVF   77,W
1A01:  BSF    03,6
1A02:  IORWF  31,W
1A03:  BCF    03,6
1A04:  MOVWF  5C
*
1A19:  CLRF   32
1A1A:  MOVF   2F,W
1A1B:  MOVWF  31
1A1C:  MOVF   31,W
1A1D:  MOVWF  32
1A1E:  CLRF   31
1A1F:  BCF    03,6
1A20:  CLRF   7A
1A21:  BSF    03,6
1A22:  MOVF   30,W
1A23:  BCF    03,6
1A24:  MOVWF  77
1A25:  MOVF   7A,W
1A26:  BSF    03,6
1A27:  IORWF  32,W
1A28:  BCF    03,6
1A29:  MOVWF  5B
1A2A:  MOVF   77,W
1A2B:  BSF    03,6
1A2C:  IORWF  31,W
1A2D:  BCF    03,6
1A2E:  MOVWF  5A
....................     return(!atend); 
*
0C3E:  MOVLW  00
0C3F:  BCF    03,6
0C40:  BTFSS  26,1
0C41:  MOVLW  01
0C42:  MOVWF  78
*
183B:  MOVLW  00
183C:  BTFSS  26,1
183D:  MOVLW  01
183E:  MOVWF  78
*
18FA:  MOVLW  00
18FB:  BCF    03,6
18FC:  BTFSS  26,1
18FD:  MOVLW  01
18FE:  MOVWF  78
*
1A05:  MOVLW  00
1A06:  BTFSS  26,1
1A07:  MOVLW  01
1A08:  MOVWF  78
*
1A2F:  MOVLW  00
1A30:  BTFSS  26,1
1A31:  MOVLW  01
1A32:  MOVWF  78
.................... } 
.................... /* Get an incoming lword value, return 0 if end of message */ 
.................... BOOL get_lword(LWORD &lw) 
.................... { 
....................     lw.b[3] = getch_net(); 
*
0C65:  CALL   269
0C66:  MOVF   78,W
0C67:  MOVWF  59
*
186C:  BCF    0A,4
186D:  CALL   269
186E:  BSF    0A,4
186F:  MOVF   78,W
1870:  MOVWF  59
*
1A36:  BCF    0A,4
1A37:  CALL   269
1A38:  BSF    0A,4
1A39:  MOVF   78,W
1A3A:  MOVWF  61
*
1A51:  BCF    0A,4
1A52:  CALL   269
1A53:  BSF    0A,4
1A54:  MOVF   78,W
1A55:  MOVWF  65
....................     lw.b[2] = getch_net(); 
*
0C68:  CALL   269
0C69:  MOVF   78,W
0C6A:  MOVWF  58
*
1871:  BCF    0A,4
1872:  CALL   269
1873:  BSF    0A,4
1874:  MOVF   78,W
1875:  MOVWF  58
*
1A3B:  BCF    0A,4
1A3C:  CALL   269
1A3D:  BSF    0A,4
1A3E:  MOVF   78,W
1A3F:  MOVWF  60
*
1A56:  BCF    0A,4
1A57:  CALL   269
1A58:  BSF    0A,4
1A59:  MOVF   78,W
1A5A:  MOVWF  64
....................     lw.b[1] = getch_net(); 
*
0C6B:  CALL   269
0C6C:  MOVF   78,W
0C6D:  MOVWF  57
*
1876:  BCF    0A,4
1877:  CALL   269
1878:  BSF    0A,4
1879:  MOVF   78,W
187A:  MOVWF  57
*
1A40:  BCF    0A,4
1A41:  CALL   269
1A42:  BSF    0A,4
1A43:  MOVF   78,W
1A44:  MOVWF  5F
*
1A5B:  BCF    0A,4
1A5C:  CALL   269
1A5D:  BSF    0A,4
1A5E:  MOVF   78,W
1A5F:  MOVWF  63
....................     lw.b[0] = getch_net(); 
*
0C6E:  CALL   269
0C6F:  MOVF   78,W
0C70:  MOVWF  56
*
187B:  BCF    0A,4
187C:  CALL   269
187D:  BSF    0A,4
187E:  MOVF   78,W
187F:  MOVWF  56
*
1A45:  BCF    0A,4
1A46:  CALL   269
1A47:  BSF    0A,4
1A48:  MOVF   78,W
1A49:  MOVWF  5E
*
1A60:  BCF    0A,4
1A61:  CALL   269
1A62:  BSF    0A,4
1A63:  MOVF   78,W
1A64:  MOVWF  62
....................     return(!atend); 
*
0C71:  MOVLW  00
0C72:  BTFSS  26,1
0C73:  MOVLW  01
0C74:  MOVWF  78
*
1880:  MOVLW  00
1881:  BTFSS  26,1
1882:  MOVLW  01
1883:  MOVWF  78
*
1A4A:  MOVLW  00
1A4B:  BTFSS  26,1
1A4C:  MOVLW  01
1A4D:  MOVWF  78
*
1A65:  MOVLW  00
1A66:  BTFSS  26,1
1A67:  MOVLW  01
1A68:  MOVWF  78
.................... } 
....................  
.................... /* Match an incoming byte value, return 0 not matched, or end of message */ 
.................... BOOL match_byte(BYTE b) 
.................... { 
....................     return(b==getch_net() && !atend); 
*
0A91:  CALL   269
0A92:  MOVF   78,W
0A93:  BSF    03,6
0A94:  SUBWF  36,W
0A95:  BTFSC  03,2
0A96:  GOTO   299
0A97:  BCF    03,6
0A98:  GOTO   29C
0A99:  BCF    03,6
0A9A:  BTFSS  26,1
0A9B:  GOTO   29E
0A9C:  MOVLW  00
0A9D:  GOTO   29F
0A9E:  MOVLW  01
0A9F:  MOVWF  78
0AA0:  RETLW  00
.................... } 
.................... /* Match an incoming byte value, return 0 not matched, or end of message */ 
.................... BOOL match_word(WORD w) 
.................... { 
....................     WORD inw; 
....................  
....................     return(get_word(inw) && inw==w); 
*
0C43:  MOVF   78,F
0C44:  BTFSC  03,2
0C45:  GOTO   456
0C46:  BSF    03,6
0C47:  MOVF   27,W
0C48:  SUBWF  29,W
0C49:  BTFSC  03,2
0C4A:  GOTO   44D
0C4B:  BCF    03,6
0C4C:  GOTO   456
0C4D:  BCF    03,6
0C4E:  BSF    03,6
0C4F:  MOVF   26,W
0C50:  SUBWF  28,W
0C51:  BTFSS  03,2
0C52:  GOTO   455
0C53:  BCF    03,6
0C54:  GOTO   458
0C55:  BCF    03,6
0C56:  MOVLW  00
0C57:  GOTO   459
0C58:  MOVLW  01
0C59:  MOVWF  78
.................... } 
....................  
.................... /* Match longword */ 
.................... BOOL match_lword(LWORD &lw) 
.................... { 
....................     return (match_byte(lw.b[3]) && match_byte(lw.b[2]) &&  
....................         match_byte(lw.b[1]) && match_byte(lw.b[0])); 
*
0C80:  MOVF   51,W
0C81:  BSF    03,6
0C82:  MOVWF  36
0C83:  BCF    03,6
0C84:  CALL   291
0C85:  MOVF   78,F
0C86:  BTFSC  03,2
0C87:  GOTO   4A0
0C88:  MOVF   50,W
0C89:  BSF    03,6
0C8A:  MOVWF  36
0C8B:  BCF    03,6
0C8C:  CALL   291
0C8D:  MOVF   78,F
0C8E:  BTFSC  03,2
0C8F:  GOTO   4A0
0C90:  MOVF   4F,W
0C91:  BSF    03,6
0C92:  MOVWF  36
0C93:  BCF    03,6
0C94:  CALL   291
0C95:  MOVF   78,F
0C96:  BTFSC  03,2
0C97:  GOTO   4A0
0C98:  MOVF   4E,W
0C99:  BSF    03,6
0C9A:  MOVWF  36
0C9B:  BCF    03,6
0C9C:  CALL   291
0C9D:  MOVF   78,F
0C9E:  BTFSS  03,2
0C9F:  GOTO   4A2
0CA0:  MOVLW  00
0CA1:  GOTO   4A3
0CA2:  MOVLW  01
0CA3:  MOVWF  78
*
1887:  MOVF   51,W
1888:  BSF    03,6
1889:  MOVWF  36
188A:  BCF    03,6
188B:  BCF    0A,4
188C:  CALL   291
188D:  BSF    0A,4
188E:  MOVF   78,F
188F:  BTFSC  03,2
1890:  GOTO   0AF
1891:  MOVF   50,W
1892:  BSF    03,6
1893:  MOVWF  36
1894:  BCF    03,6
1895:  BCF    0A,4
1896:  CALL   291
1897:  BSF    0A,4
1898:  MOVF   78,F
1899:  BTFSC  03,2
189A:  GOTO   0AF
189B:  MOVF   4F,W
189C:  BSF    03,6
189D:  MOVWF  36
189E:  BCF    03,6
189F:  BCF    0A,4
18A0:  CALL   291
18A1:  BSF    0A,4
18A2:  MOVF   78,F
18A3:  BTFSC  03,2
18A4:  GOTO   0AF
18A5:  MOVF   4E,W
18A6:  BSF    03,6
18A7:  MOVWF  36
18A8:  BCF    03,6
18A9:  BCF    0A,4
18AA:  CALL   291
18AB:  BSF    0A,4
18AC:  MOVF   78,F
18AD:  BTFSS  03,2
18AE:  GOTO   0B1
18AF:  MOVLW  00
18B0:  GOTO   0B2
18B1:  MOVLW  01
18B2:  MOVWF  78
.................... } 
....................  
.................... /* Skip whitespace & ctrl chars in incoming data, return 0 if none */ 
.................... void skip_space(void) 
.................... {           
....................     BYTE b; 
....................     BOOL ok=0; 
....................      
....................     while (get_byte(b) && b<=' ') 
....................         ok = 1; 
....................     if (ok) 
....................         unget_byte(b); 
.................... } 
....................  
.................... /* Skip an incoming byte value, return 0 if end of message */ 
.................... BOOL skip_byte(void) 
.................... { 
....................     getch_net(); 
*
0D20:  CALL   269
....................     return(!atend); 
0D21:  MOVLW  00
0D22:  BTFSS  26,1
0D23:  MOVLW  01
0D24:  MOVWF  78
0D25:  RETLW  00
.................... } 
.................... /* Skip an incoming word value, return 0 if end of message */ 
.................... BOOL skip_word(void) 
.................... { 
....................     getch_net(); 
*
0AAA:  CALL   269
....................     getch_net(); 
0AAB:  CALL   269
....................     return(!atend); 
0AAC:  MOVLW  00
0AAD:  BTFSS  26,1
0AAE:  MOVLW  01
0AAF:  MOVWF  78
0AB0:  RETLW  00
.................... } 
.................... /* Skip an incoming lword value, return 0 if end of message */ 
.................... BOOL skip_lword(void) 
.................... { 
....................     getch_net(); 
*
0AA1:  CALL   269
....................     getch_net(); 
0AA2:  CALL   269
....................     getch_net(); 
0AA3:  CALL   269
....................     getch_net(); 
0AA4:  CALL   269
....................     return(!atend); 
0AA5:  MOVLW  00
0AA6:  BTFSS  26,1
0AA7:  MOVLW  01
0AA8:  MOVWF  78
0AA9:  RETLW  00
.................... } 
....................   
.................... /* Compute checksum of a string, return its length */ 
.................... int check_str(char *s) 
.................... { 
....................     char c; 
....................     int n=0; 
....................  
....................     while ((c = s[n])!=0) 
....................     { 
....................         check_byte(c); 
....................         n++; 
....................     } 
....................     return(n); 
.................... } 
....................  
.................... /* Add byte to checksum value */ 
.................... void check_byte(BYTE b) 
.................... { 
....................     if (checkflag) 
*
0A49:  BTFSS  26,2
0A4A:  GOTO   259
....................     { 
....................         if ((checklo = b+checklo) < b) 
0A4B:  BSF    03,6
0A4C:  MOVF   3E,W
0A4D:  BCF    03,6
0A4E:  ADDWF  4B,F
0A4F:  BSF    03,6
0A50:  MOVF   3E,W
0A51:  BCF    03,6
0A52:  SUBWF  4B,W
0A53:  BTFSC  03,0
0A54:  GOTO   258
....................         { 
....................             if (++checkhi == 0) 
0A55:  INCFSZ 4A,F
0A56:  GOTO   258
....................                 checklo++; 
0A57:  INCF   4B,F
....................         } 
....................     } 
....................     else 
0A58:  GOTO   266
....................     { 
....................         if ((checkhi = b+checkhi) < b) 
0A59:  BSF    03,6
0A5A:  MOVF   3E,W
0A5B:  BCF    03,6
0A5C:  ADDWF  4A,F
0A5D:  BSF    03,6
0A5E:  MOVF   3E,W
0A5F:  BCF    03,6
0A60:  SUBWF  4A,W
0A61:  BTFSC  03,0
0A62:  GOTO   266
....................         { 
....................             if (++checklo == 0) 
0A63:  INCFSZ 4B,F
0A64:  GOTO   266
....................                 checkhi++; 
0A65:  INCF   4A,F
....................         } 
....................     } 
....................     checkflag = !checkflag; 
0A66:  MOVLW  04
0A67:  XORWF  26,F
0A68:  RETLW  00
.................... } 
.................... /* Add word to checksum value */ 
.................... void check_word(WORD w) 
.................... { 
....................     check_byte(w>>8); 
*
0DDA:  BSF    03,6
0DDB:  MOVF   39,W
0DDC:  MOVWF  3A
0DDD:  CLRF   3B
0DDE:  MOVF   3A,W
0DDF:  MOVWF  3E
0DE0:  BCF    03,6
0DE1:  CALL   249
....................     check_byte(w); 
0DE2:  BSF    03,6
0DE3:  MOVF   38,W
0DE4:  MOVWF  3E
0DE5:  BCF    03,6
0DE6:  CALL   249
0DE7:  RETLW  00
.................... } 
.................... /* Add longword to checksum value */ 
.................... void check_lword(LWORD &lw) 
.................... { 
....................     check_byte(lw.b[3]); 
*
0D56:  MOVF   51,W
0D57:  BSF    03,6
0D58:  MOVWF  3E
0D59:  BCF    03,6
0D5A:  CALL   249
*
0D6A:  MOVF   59,W
0D6B:  BSF    03,6
0D6C:  MOVWF  3E
0D6D:  BCF    03,6
0D6E:  CALL   249
*
1100:  MOVF   51,W
1101:  BSF    03,6
1102:  MOVWF  3E
1103:  BCF    03,6
1104:  BCF    0A,4
1105:  BSF    0A,3
1106:  CALL   249
1107:  BSF    0A,4
1108:  BCF    0A,3
*
1124:  MOVF   59,W
1125:  BSF    03,6
1126:  MOVWF  3E
1127:  BCF    03,6
1128:  BCF    0A,4
1129:  BSF    0A,3
112A:  CALL   249
112B:  BSF    0A,4
112C:  BCF    0A,3
*
1AB1:  MOVF   51,W
1AB2:  BSF    03,6
1AB3:  MOVWF  3E
1AB4:  BCF    03,6
1AB5:  BCF    0A,4
1AB6:  CALL   249
1AB7:  BSF    0A,4
*
1ACD:  MOVF   59,W
1ACE:  BSF    03,6
1ACF:  MOVWF  3E
1AD0:  BCF    03,6
1AD1:  BCF    0A,4
1AD2:  CALL   249
1AD3:  BSF    0A,4
....................     check_byte(lw.b[2]); 
*
0D5B:  MOVF   50,W
0D5C:  BSF    03,6
0D5D:  MOVWF  3E
0D5E:  BCF    03,6
0D5F:  CALL   249
*
0D6F:  MOVF   58,W
0D70:  BSF    03,6
0D71:  MOVWF  3E
0D72:  BCF    03,6
0D73:  CALL   249
*
1109:  MOVF   50,W
110A:  BSF    03,6
110B:  MOVWF  3E
110C:  BCF    03,6
110D:  BCF    0A,4
110E:  BSF    0A,3
110F:  CALL   249
1110:  BSF    0A,4
1111:  BCF    0A,3
*
112D:  MOVF   58,W
112E:  BSF    03,6
112F:  MOVWF  3E
1130:  BCF    03,6
1131:  BCF    0A,4
1132:  BSF    0A,3
1133:  CALL   249
1134:  BSF    0A,4
1135:  BCF    0A,3
*
1AB8:  MOVF   50,W
1AB9:  BSF    03,6
1ABA:  MOVWF  3E
1ABB:  BCF    03,6
1ABC:  BCF    0A,4
1ABD:  CALL   249
1ABE:  BSF    0A,4
*
1AD4:  MOVF   58,W
1AD5:  BSF    03,6
1AD6:  MOVWF  3E
1AD7:  BCF    03,6
1AD8:  BCF    0A,4
1AD9:  CALL   249
1ADA:  BSF    0A,4
....................     check_byte(lw.b[1]); 
*
0D60:  MOVF   4F,W
0D61:  BSF    03,6
0D62:  MOVWF  3E
0D63:  BCF    03,6
0D64:  CALL   249
*
0D74:  MOVF   57,W
0D75:  BSF    03,6
0D76:  MOVWF  3E
0D77:  BCF    03,6
0D78:  CALL   249
*
1112:  MOVF   4F,W
1113:  BSF    03,6
1114:  MOVWF  3E
1115:  BCF    03,6
1116:  BCF    0A,4
1117:  BSF    0A,3
1118:  CALL   249
1119:  BSF    0A,4
111A:  BCF    0A,3
*
1136:  MOVF   57,W
1137:  BSF    03,6
1138:  MOVWF  3E
1139:  BCF    03,6
113A:  BCF    0A,4
113B:  BSF    0A,3
113C:  CALL   249
113D:  BSF    0A,4
113E:  BCF    0A,3
*
1ABF:  MOVF   4F,W
1AC0:  BSF    03,6
1AC1:  MOVWF  3E
1AC2:  BCF    03,6
1AC3:  BCF    0A,4
1AC4:  CALL   249
1AC5:  BSF    0A,4
*
1ADB:  MOVF   57,W
1ADC:  BSF    03,6
1ADD:  MOVWF  3E
1ADE:  BCF    03,6
1ADF:  BCF    0A,4
1AE0:  CALL   249
1AE1:  BSF    0A,4
....................     check_byte(lw.b[0]); 
*
0D65:  MOVF   4E,W
0D66:  BSF    03,6
0D67:  MOVWF  3E
0D68:  BCF    03,6
0D69:  CALL   249
*
0D79:  MOVF   56,W
0D7A:  BSF    03,6
0D7B:  MOVWF  3E
0D7C:  BCF    03,6
0D7D:  CALL   249
*
111B:  MOVF   4E,W
111C:  BSF    03,6
111D:  MOVWF  3E
111E:  BCF    03,6
111F:  BCF    0A,4
1120:  BSF    0A,3
1121:  CALL   249
1122:  BSF    0A,4
1123:  BCF    0A,3
*
113F:  MOVF   56,W
1140:  BSF    03,6
1141:  MOVWF  3E
1142:  BCF    03,6
1143:  BCF    0A,4
1144:  BSF    0A,3
1145:  CALL   249
1146:  BSF    0A,4
1147:  BCF    0A,3
*
1AC6:  MOVF   4E,W
1AC7:  BSF    03,6
1AC8:  MOVWF  3E
1AC9:  BCF    03,6
1ACA:  BCF    0A,4
1ACB:  CALL   249
1ACC:  BSF    0A,4
*
1AE2:  MOVF   56,W
1AE3:  BSF    03,6
1AE4:  MOVWF  3E
1AE5:  BCF    03,6
1AE6:  BCF    0A,4
1AE7:  CALL   249
1AE8:  BSF    0A,4
.................... } 
....................  
.................... /* Add array of bytes to checksum value */ 
.................... void check_bytes(BYTE *dat, int len) 
.................... { 
....................     while (len--) 
....................         check_byte(*dat++); 
.................... } 
....................  
.................... /* Send a byte to the network buffer */ 
.................... void put_byte(BYTE b) 
.................... { 
....................     putch_net(b); 
*
0AD4:  BSF    03,6
0AD5:  MOVF   39,W
0AD6:  MOVWF  3C
0AD7:  BCF    03,6
0AD8:  CALL   2B1
0AD9:  RETLW  00
.................... } 
....................  
.................... /* Send a string out to the SLIP link, add to checksum */ 
.................... void put_str(char *s) 
.................... { 
....................     while (*s) 
....................         putch_net(*s++); 
.................... } 
....................  
.................... /* Send a word out to the SLIP link, then add to checksum */ 
.................... void put_word(WORD w) 
.................... { 
....................     putch_net(w >> 8); 
*
0AC6:  BSF    03,6
0AC7:  MOVF   39,W
0AC8:  MOVWF  3A
0AC9:  CLRF   3B
0ACA:  MOVF   3A,W
0ACB:  MOVWF  3C
0ACC:  BCF    03,6
0ACD:  CALL   2B1
....................     putch_net(w); 
0ACE:  BSF    03,6
0ACF:  MOVF   38,W
0AD0:  MOVWF  3C
0AD1:  BCF    03,6
0AD2:  CALL   2B1
0AD3:  RETLW  00
.................... } 
....................  
.................... void put_lword(LWORD &lw) 
.................... { 
....................     putch_net(lw.b[3]); 
*
0CD0:  MOVF   51,W
0CD1:  BSF    03,6
0CD2:  MOVWF  3C
0CD3:  BCF    03,6
0CD4:  CALL   2B1
*
0CED:  MOVF   59,W
0CEE:  BSF    03,6
0CEF:  MOVWF  3C
0CF0:  BCF    03,6
0CF1:  CALL   2B1
*
0D8E:  MOVF   51,W
0D8F:  BSF    03,6
0D90:  MOVWF  3C
0D91:  BCF    03,6
0D92:  CALL   2B1
*
0DA2:  MOVF   59,W
0DA3:  BSF    03,6
0DA4:  MOVWF  3C
0DA5:  BCF    03,6
0DA6:  CALL   2B1
*
104B:  MOVF   65,W
104C:  BSF    03,6
104D:  MOVWF  3C
104E:  BCF    03,6
104F:  BCF    0A,4
1050:  BSF    0A,3
1051:  CALL   2B1
1052:  BSF    0A,4
1053:  BCF    0A,3
*
106F:  MOVF   61,W
1070:  BSF    03,6
1071:  MOVWF  3C
1072:  BCF    03,6
1073:  BCF    0A,4
1074:  BSF    0A,3
1075:  CALL   2B1
1076:  BSF    0A,4
1077:  BCF    0A,3
....................     putch_net(lw.b[2]); 
*
0CD5:  MOVF   50,W
0CD6:  BSF    03,6
0CD7:  MOVWF  3C
0CD8:  BCF    03,6
0CD9:  CALL   2B1
*
0CF2:  MOVF   58,W
0CF3:  BSF    03,6
0CF4:  MOVWF  3C
0CF5:  BCF    03,6
0CF6:  CALL   2B1
*
0D93:  MOVF   50,W
0D94:  BSF    03,6
0D95:  MOVWF  3C
0D96:  BCF    03,6
0D97:  CALL   2B1
*
0DA7:  MOVF   58,W
0DA8:  BSF    03,6
0DA9:  MOVWF  3C
0DAA:  BCF    03,6
0DAB:  CALL   2B1
*
1054:  MOVF   64,W
1055:  BSF    03,6
1056:  MOVWF  3C
1057:  BCF    03,6
1058:  BCF    0A,4
1059:  BSF    0A,3
105A:  CALL   2B1
105B:  BSF    0A,4
105C:  BCF    0A,3
*
1078:  MOVF   60,W
1079:  BSF    03,6
107A:  MOVWF  3C
107B:  BCF    03,6
107C:  BCF    0A,4
107D:  BSF    0A,3
107E:  CALL   2B1
107F:  BSF    0A,4
1080:  BCF    0A,3
....................     putch_net(lw.b[1]); 
*
0CDA:  MOVF   4F,W
0CDB:  BSF    03,6
0CDC:  MOVWF  3C
0CDD:  BCF    03,6
0CDE:  CALL   2B1
*
0CF7:  MOVF   57,W
0CF8:  BSF    03,6
0CF9:  MOVWF  3C
0CFA:  BCF    03,6
0CFB:  CALL   2B1
*
0D98:  MOVF   4F,W
0D99:  BSF    03,6
0D9A:  MOVWF  3C
0D9B:  BCF    03,6
0D9C:  CALL   2B1
*
0DAC:  MOVF   57,W
0DAD:  BSF    03,6
0DAE:  MOVWF  3C
0DAF:  BCF    03,6
0DB0:  CALL   2B1
*
105D:  MOVF   63,W
105E:  BSF    03,6
105F:  MOVWF  3C
1060:  BCF    03,6
1061:  BCF    0A,4
1062:  BSF    0A,3
1063:  CALL   2B1
1064:  BSF    0A,4
1065:  BCF    0A,3
*
1081:  MOVF   5F,W
1082:  BSF    03,6
1083:  MOVWF  3C
1084:  BCF    03,6
1085:  BCF    0A,4
1086:  BSF    0A,3
1087:  CALL   2B1
1088:  BSF    0A,4
1089:  BCF    0A,3
....................     putch_net(lw.b[0]); 
*
0CDF:  MOVF   4E,W
0CE0:  BSF    03,6
0CE1:  MOVWF  3C
0CE2:  BCF    03,6
0CE3:  CALL   2B1
*
0CFC:  MOVF   56,W
0CFD:  BSF    03,6
0CFE:  MOVWF  3C
0CFF:  BCF    03,6
0D00:  CALL   2B1
*
0D9D:  MOVF   4E,W
0D9E:  BSF    03,6
0D9F:  MOVWF  3C
0DA0:  BCF    03,6
0DA1:  CALL   2B1
*
0DB1:  MOVF   56,W
0DB2:  BSF    03,6
0DB3:  MOVWF  3C
0DB4:  BCF    03,6
0DB5:  CALL   2B1
*
1066:  MOVF   62,W
1067:  BSF    03,6
1068:  MOVWF  3C
1069:  BCF    03,6
106A:  BCF    0A,4
106B:  BSF    0A,3
106C:  CALL   2B1
106D:  BSF    0A,4
106E:  BCF    0A,3
*
108A:  MOVF   5E,W
108B:  BSF    03,6
108C:  MOVWF  3C
108D:  BCF    03,6
108E:  BCF    0A,4
108F:  BSF    0A,3
1090:  CALL   2B1
1091:  BSF    0A,4
1092:  BCF    0A,3
.................... } 
....................  
.................... void put_data(BYTE *data, int len) 
.................... { 
....................     while (len--) 
*
0ADA:  BSF    03,6
0ADB:  MOVF   28,W
0ADC:  DECF   28,F
0ADD:  IORLW  00
0ADE:  BTFSS  03,2
0ADF:  GOTO   2E2
0AE0:  BCF    03,6
0AE1:  GOTO   2F9
0AE2:  BCF    03,6
....................         putch_net(*data++); 
0AE3:  BSF    03,6
0AE4:  MOVF   27,W
0AE5:  BCF    03,6
0AE6:  MOVWF  7A
0AE7:  BSF    03,6
0AE8:  MOVF   26,W
0AE9:  INCF   26,F
0AEA:  BTFSC  03,2
0AEB:  INCF   27,F
0AEC:  MOVWF  04
0AED:  BCF    03,7
0AEE:  BCF    03,6
0AEF:  BTFSC  7A,0
0AF0:  BSF    03,7
0AF1:  MOVF   00,W
0AF2:  BSF    03,6
0AF3:  MOVWF  29
0AF4:  MOVF   29,W
0AF5:  MOVWF  3C
0AF6:  BCF    03,6
0AF7:  CALL   2B1
0AF8:  GOTO   2DA
0AF9:  RETLW  00
.................... } 
....................  
.................... /* Swap the bytes in a word */ 
.................... void swapw(WORD &val) 
.................... { 
....................     val = (val >> 8) | ((val << 8) & 0xff00); 
*
09A0:  MOVF   43,W
09A1:  BSF    03,6
09A2:  MOVWF  3C
09A3:  CLRF   3D
09A4:  BCF    03,6
09A5:  MOVF   42,W
09A6:  BSF    03,6
09A7:  MOVWF  3F
09A8:  CLRF   3E
09A9:  MOVF   3F,W
09AA:  BCF    03,6
09AB:  MOVWF  7A
09AC:  BSF    03,6
09AD:  MOVF   3E,W
09AE:  ANDLW  00
09AF:  BCF    03,6
09B0:  MOVWF  77
09B1:  MOVF   7A,W
09B2:  BSF    03,6
09B3:  IORWF  3D,W
09B4:  BCF    03,6
09B5:  MOVWF  43
09B6:  MOVF   77,W
09B7:  BSF    03,6
09B8:  IORWF  3C,W
09B9:  BCF    03,6
09BA:  MOVWF  42
*
0B7F:  MOVF   43,W
0B80:  BSF    03,6
0B81:  MOVWF  3C
0B82:  CLRF   3D
0B83:  BCF    03,6
0B84:  MOVF   42,W
0B85:  BSF    03,6
0B86:  MOVWF  3F
0B87:  CLRF   3E
0B88:  MOVF   3F,W
0B89:  BCF    03,6
0B8A:  MOVWF  7A
0B8B:  BSF    03,6
0B8C:  MOVF   3E,W
0B8D:  ANDLW  00
0B8E:  BCF    03,6
0B8F:  MOVWF  77
0B90:  MOVF   7A,W
0B91:  BSF    03,6
0B92:  IORWF  3D,W
0B93:  BCF    03,6
0B94:  MOVWF  43
0B95:  MOVF   77,W
0B96:  BSF    03,6
0B97:  IORWF  3C,W
0B98:  BCF    03,6
0B99:  MOVWF  42
.................... } 
....................  
.................... /* EOF */ 
.................... 
.................... #include "\chipweb\pcm\p16_lcd.h" 
....................  /* LCD driver for PICDEM-NET board  
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
.................... /* 
.................... ** v0.01 JPB 7/12/00  Adapted from LCD188.C v0.04 
.................... ** v0.02 JPB 27/12/00 Adapted for new (v3) PICDEM.net board 
.................... */ 
....................                     
.................... #define LCD_FUJI 1  // Set non-zero for Fuji FCS2314AK, zero for Hitachi 
....................  
.................... #if OLD_BOARD 
.................... #BIT    LCD_E        = PORTA.1 
.................... #BIT    LCD_RD       = PORTA.2 
.................... #BIT    LCD_RS       = PORTA.3 
.................... #BYTE   LCD_DATA     = PORTD 
....................  
.................... #else 
.................... struct { 
....................     BYTE data:4; 
....................     BYTE regsel:1; 
....................     BYTE read:1; 
.................... } LCD_PORT; 
.................... #BYTE LCD_PORT = 8                                 
.................... #BIT    LCD_E        = PORTA.5 
.................... #define LCD_RD       LCD_PORT.read 
.................... #define LCD_RS       LCD_PORT.regsel 
.................... #define LCD_DATA     LCD_PORT.data 
.................... #endif 
....................  
.................... #define DATA_TO_LCD    set_tris_d(ALL_OUT) 
.................... #define DATA_FROM_LCD  set_tris_d(0x0f) 
....................  
.................... #if LCD_FUJI 
.................... #define LCD_SETPOS   0x80 
.................... #define LCD_MODE     0x28 
.................... #else 
.................... #define LCD_SETPOS   0x80 
.................... #endif 
.................... #define LCD_LINE2    0x40 
....................  
.................... BOOL disp_lcd, disp_serial;      // Flags to enable display O/Ps 
....................  
.................... /* Local prototypes */ 
.................... void lcd_cmd(BYTE b); 
.................... void lcd_char(BYTE b); 
.................... void lcd_byte(BYTE &b); 
.................... void lcd_nybble(BYTE b); 
....................  
.................... /* Display handler; redirects to LCD and/or serial */ 
.................... void displays(BYTE b) 
.................... {                     
....................     if (disp_lcd) 
*
0185:  BTFSS  26,4
0186:  GOTO   1C4
....................     { 
....................         if (b == '\r') 
0187:  MOVLW  0D
0188:  BSF    03,6
0189:  SUBWF  31,W
018A:  BTFSC  03,2
018B:  GOTO   18E
018C:  BCF    03,6
018D:  GOTO   195
018E:  BCF    03,6
....................             lcd_cmd(LCD_SETPOS); 
018F:  MOVLW  80
0190:  BSF    03,6
0191:  MOVWF  32
0192:  BCF    03,6
0193:  CALL   114
....................         else if (b == '\n') 
0194:  GOTO   1C4
0195:  MOVLW  0A
0196:  BSF    03,6
0197:  SUBWF  31,W
0198:  BTFSC  03,2
0199:  GOTO   19C
019A:  BCF    03,6
019B:  GOTO   1A3
019C:  BCF    03,6
....................             lcd_cmd(LCD_SETPOS + LCD_LINE2); 
019D:  MOVLW  C0
019E:  BSF    03,6
019F:  MOVWF  32
01A0:  BCF    03,6
01A1:  CALL   114
....................         else 
01A2:  GOTO   1C4
....................             lcd_char(b); 
01A3:  BSF    03,6
01A4:  MOVF   31,W
01A5:  MOVWF  32
....................     } 
....................     if (disp_serial) 
*
01C4:  BTFSS  26,5
01C5:  GOTO   1D8
....................     { 
....................         if (b == '\n') 
01C6:  MOVLW  0A
01C7:  BSF    03,6
01C8:  SUBWF  31,W
01C9:  BTFSC  03,2
01CA:  GOTO   1CD
01CB:  BCF    03,6
01CC:  GOTO   1D2
01CD:  BCF    03,6
....................             putchar('\r'); 
01CE:  MOVLW  0D
01CF:  BTFSS  0C,4
01D0:  GOTO   1CF
01D1:  MOVWF  19
....................         putchar(b); 
01D2:  BSF    03,6
01D3:  MOVF   31,W
01D4:  BCF    03,6
01D5:  BTFSS  0C,4
01D6:  GOTO   1D5
01D7:  MOVWF  19
....................     } 
01D8:  RETLW  00
.................... } 
....................  
.................... /* Display a byte in unsigned decimal format */ 
.................... void disp_decbyte(BYTE b) 
.................... { 
....................     printf(displays, "%u", b); 
*
07D6:  BSF    03,6
07D7:  MOVF   3D,W
07D8:  BCF    03,6
07D9:  CLRF   78
07DA:  BSF    03,6
07DB:  SUBWF  3C,W
07DC:  BTFSS  03,0
07DD:  GOTO   7E0
07DE:  BCF    03,6
07DF:  GOTO   7E4
07E0:  MOVF   3C,W
07E1:  BCF    03,6
07E2:  MOVWF  77
07E3:  GOTO   7FB
07E4:  CLRF   77
07E5:  MOVLW  08
07E6:  BSF    03,6
07E7:  MOVWF  3E
07E8:  BCF    03,6
07E9:  BSF    03,6
07EA:  RLF    3C,F
07EB:  BCF    03,6
07EC:  RLF    77,F
07ED:  BSF    03,6
07EE:  MOVF   3D,W
07EF:  BCF    03,6
07F0:  SUBWF  77,W
07F1:  BTFSC  03,0
07F2:  MOVWF  77
07F3:  RLF    78,F
07F4:  BSF    03,6
07F5:  DECFSZ 3E,F
07F6:  GOTO   7F8
07F7:  GOTO   7FA
07F8:  BCF    03,6
07F9:  GOTO   7E9
07FA:  BCF    03,6
07FB:  RETLW  00
*
0800:  BSF    03,6
0801:  BTFSS  27,0
0802:  GOTO   005
0803:  BCF    03,6
0804:  GOTO   02E
0805:  BTFSS  27,1
0806:  GOTO   009
0807:  BCF    03,6
0808:  GOTO   04F
0809:  MOVF   26,W
080A:  MOVWF  3C
080B:  MOVLW  64
080C:  MOVWF  3D
080D:  BCF    03,6
080E:  BCF    0A,3
080F:  CALL   7D6
0810:  BSF    0A,3
0811:  MOVF   77,W
0812:  BSF    03,6
0813:  MOVWF  26
0814:  BCF    03,6
0815:  MOVF   78,W
0816:  MOVLW  30
0817:  BTFSS  03,2
0818:  GOTO   022
0819:  BSF    03,6
081A:  BTFSS  27,2
081B:  GOTO   01E
081C:  BCF    03,6
081D:  GOTO   02E
081E:  BTFSC  27,3
081F:  MOVLW  20
0820:  BCF    03,6
0821:  GOTO   026
0822:  BSF    03,6
0823:  BCF    27,2
0824:  BCF    27,3
0825:  BCF    03,6
0826:  ADDWF  78,F
0827:  MOVF   78,W
0828:  BSF    03,6
0829:  MOVWF  31
082A:  BCF    03,6
082B:  BCF    0A,3
082C:  CALL   185
082D:  BSF    0A,3
082E:  BSF    03,6
082F:  MOVF   26,W
0830:  MOVWF  3C
0831:  MOVLW  0A
0832:  MOVWF  3D
0833:  BCF    03,6
0834:  BCF    0A,3
0835:  CALL   7D6
0836:  BSF    0A,3
0837:  MOVF   77,W
0838:  BSF    03,6
0839:  MOVWF  26
083A:  BCF    03,6
083B:  MOVF   78,W
083C:  MOVLW  30
083D:  BTFSS  03,2
083E:  GOTO   047
083F:  BSF    03,6
0840:  BTFSS  27,2
0841:  GOTO   044
0842:  BCF    03,6
0843:  GOTO   04F
0844:  BTFSC  27,3
0845:  MOVLW  20
0846:  BCF    03,6
0847:  ADDWF  78,F
0848:  MOVF   78,W
0849:  BSF    03,6
084A:  MOVWF  31
084B:  BCF    03,6
084C:  BCF    0A,3
084D:  CALL   185
084E:  BSF    0A,3
084F:  MOVLW  30
0850:  BSF    03,6
0851:  ADDWF  26,F
0852:  MOVF   26,W
0853:  MOVWF  31
0854:  BCF    03,6
0855:  BCF    0A,3
0856:  CALL   185
0857:  BSF    0A,3
0858:  BSF    0A,3
0859:  BCF    0A,4
085A:  GOTO   062
085B:  BSF    03,6
085C:  MOVF   25,W
085D:  MOVWF  26
085E:  MOVLW  0C
085F:  MOVWF  27
0860:  BCF    03,6
0861:  GOTO   000
0862:  RETLW  00
.................... } 
....................  
.................... /* Initialise the LCD */ 
.................... void init_lcd(void) 
.................... { 
....................     int i; 
....................      
....................     LCD_E = 0;                      /* Clear LCD clock line */ 
*
0140:  BCF    05,5
....................     DATA_FROM_LCD;                  /* Ensure RS and RD lines are O/Ps */ 
0141:  MOVLW  0F
0142:  BSF    03,5
0143:  MOVWF  08
....................     LCD_RD = LCD_RS = 0; 
0144:  BCF    03,5
0145:  BCF    08,4
0146:  BCF    08,5
....................     delay_ms(15);                   /* Ensure LCD is stable after power-up */ 
0147:  MOVLW  0F
0148:  BSF    03,6
0149:  MOVWF  33
014A:  BCF    03,6
014B:  CALL   0ED
.................... #if LCD_FUJI                                           
....................     lcd_cmd(LCD_MODE); 
014C:  MOVLW  28
014D:  BSF    03,6
014E:  MOVWF  32
014F:  BCF    03,6
0150:  CALL   114
....................     delay_ms(5); 
0151:  MOVLW  05
0152:  BSF    03,6
0153:  MOVWF  33
0154:  BCF    03,6
0155:  CALL   0ED
....................     lcd_cmd(LCD_MODE); 
0156:  MOVLW  28
0157:  BSF    03,6
0158:  MOVWF  32
0159:  BCF    03,6
015A:  CALL   114
....................     delay_us(100); 
015B:  MOVLW  A3
015C:  MOVWF  77
015D:  DECFSZ 77,F
015E:  GOTO   15D
015F:  NOP
....................     lcd_cmd(LCD_MODE); 
0160:  MOVLW  28
0161:  BSF    03,6
0162:  MOVWF  32
0163:  BCF    03,6
0164:  CALL   114
....................     delay_us(40); 
0165:  MOVLW  41
0166:  MOVWF  77
0167:  DECFSZ 77,F
0168:  GOTO   167
....................     lcd_cmd(LCD_MODE);              /* Set 4-bit mode, 2 lines, 5x7 dots */ 
0169:  MOVLW  28
016A:  BSF    03,6
016B:  MOVWF  32
016C:  BCF    03,6
016D:  CALL   114
....................     lcd_cmd(0x04);                  /* Incrementing cursor, not horiz scroll */ 
016E:  MOVLW  04
016F:  BSF    03,6
0170:  MOVWF  32
0171:  BCF    03,6
0172:  CALL   114
....................     lcd_cmd(0x0e);                  /* Display on, cursor on, not blinking */ 
0173:  MOVLW  0E
0174:  BSF    03,6
0175:  MOVWF  32
0176:  BCF    03,6
0177:  CALL   114
....................     lcd_cmd(0x01);                  /* Clear display, home cursor */ 
0178:  MOVLW  01
0179:  BSF    03,6
017A:  MOVWF  32
017B:  BCF    03,6
017C:  CALL   114
....................     lcd_cmd(LCD_SETPOS);            /* Data address */ 
017D:  MOVLW  80
017E:  BSF    03,6
017F:  MOVWF  32
0180:  BCF    03,6
0181:  CALL   114
0182:  BCF    0A,3
0183:  BSF    0A,4
0184:  GOTO   533
.................... #else     
....................     for (i=0; i<4; i++)             /* Force into 8-bit mode */ 
....................     { 
....................         lcd_nybble(0x3); 
....................         delay_ms(5); 
....................     } 
....................     lcd_cmd(0x28);                  /* Set 4-bit mode, 2 lines, 5x7 dots */ 
....................     lcd_cmd(0x06);                  /* Incrementing cursor, not horiz scroll */ 
....................     lcd_cmd(0x0e);                  /* Display on, cursor on, not blinking */ 
....................     lcd_cmd(0x01);                  /* Clear display, home cursor */ 
.................... #endif     
.................... } 
....................  
.................... /* Go to an X-Y position on the display, top left is 1, 1 */ 
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... {                        
....................     if (y != 1) 
....................         x += LCD_LINE2; 
....................     lcd_cmd(LCD_SETPOS - 1 + x); 
.................... } 
....................  
.................... /* Send a command byte to the LCD as two nybbles */        
.................... void lcd_char(BYTE b) 
.................... {                
....................     DATA_TO_LCD; 
*
01A6:  MOVLW  00
01A7:  BSF    03,5
01A8:  BCF    03,6
01A9:  MOVWF  08
....................     LCD_RD = 0; 
01AA:  BCF    03,5
01AB:  BCF    08,5
....................     LCD_RS = 1; 
01AC:  BSF    08,4
....................     lcd_byte(b); 
.................... } 
....................  
.................... /* Send a command byte to the LCD as two nybbles */        
.................... void lcd_cmd(BYTE b) 
.................... {              
....................     DATA_TO_LCD; 
*
0114:  MOVLW  00
0115:  BSF    03,5
0116:  MOVWF  08
....................     LCD_RD = LCD_RS = 0; 
0117:  BCF    03,5
0118:  BCF    08,4
0119:  BCF    08,5
....................     lcd_byte(b); 
....................     if ((b & 0xfc) == 0) 
*
0131:  BSF    03,6
0132:  MOVF   32,W
0133:  ANDLW  FC
0134:  IORLW  00
0135:  BTFSC  03,2
0136:  GOTO   139
0137:  BCF    03,6
0138:  GOTO   13F
0139:  BCF    03,6
....................         delay_ms(2); 
013A:  MOVLW  02
013B:  BSF    03,6
013C:  MOVWF  33
013D:  BCF    03,6
013E:  CALL   0ED
013F:  RETLW  00
.................... } 
....................  
.................... /* Send a command byte to the LCD as two nybbles */        
.................... void lcd_byte(BYTE &b) 
.................... { 
....................     lcd_nybble(b >> 4); 
*
011A:  BSF    03,6
011B:  MOVF   32,W
011C:  MOVWF  33
011D:  SWAPF  33,F
011E:  MOVLW  0F
011F:  ANDWF  33,F
0120:  MOVF   33,W
0121:  MOVWF  35
0122:  BCF    03,6
0123:  CALL   103
*
01AD:  BSF    03,6
01AE:  MOVF   32,W
01AF:  MOVWF  33
01B0:  SWAPF  33,F
01B1:  MOVLW  0F
01B2:  ANDWF  33,F
01B3:  MOVF   33,W
01B4:  MOVWF  35
01B5:  BCF    03,6
01B6:  CALL   103
....................     lcd_nybble(b); 
*
0124:  BSF    03,6
0125:  MOVF   32,W
0126:  MOVWF  35
0127:  BCF    03,6
0128:  CALL   103
*
01B7:  BSF    03,6
01B8:  MOVF   32,W
01B9:  MOVWF  35
01BA:  BCF    03,6
01BB:  CALL   103
....................     DATA_FROM_LCD; 
*
0129:  MOVLW  0F
012A:  BSF    03,5
012B:  MOVWF  08
*
01BC:  MOVLW  0F
01BD:  BSF    03,5
01BE:  MOVWF  08
....................     delay_us(40); 
*
012C:  MOVLW  41
012D:  BCF    03,5
012E:  MOVWF  77
012F:  DECFSZ 77,F
0130:  GOTO   12F
*
01BF:  MOVLW  41
01C0:  BCF    03,5
01C1:  MOVWF  77
01C2:  DECFSZ 77,F
01C3:  GOTO   1C2
.................... } 
....................  
.................... /* Send a command byte to the LCD as two nybbles */        
.................... void lcd_nybble(BYTE b) 
.................... { 
....................     DATA_TO_LCD; 
*
0103:  MOVLW  00
0104:  BSF    03,5
0105:  MOVWF  08
....................     LCD_E = 1; 
0106:  BCF    03,5
0107:  BSF    05,5
....................     LCD_DATA = b; 
0108:  BSF    03,6
0109:  MOVF   35,W
010A:  ANDLW  0F
010B:  BCF    03,6
010C:  MOVWF  77
010D:  MOVF   77,W
010E:  MOVLW  F0
010F:  ANDWF  08,W
0110:  IORWF  77,W
0111:  MOVWF  08
....................     LCD_E = 0; 
0112:  BCF    05,5
0113:  RETLW  00
.................... } 
....................  
.................... /* EOF */ 
.................... 
.................... #include "\chipweb\pcm\p16_ip.h" 
....................  /* IP functions for CHIPWEB 
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
....................  
.................... #define INCLUDE_DAYTIME  1  // Set non-zero to include 'daytime' service 
....................  
.................... #define PCOL_ARP    0x0806  // Protocol type: ARP 
.................... #define PCOL_IP     0x0800  //                IP  
....................  
.................... #define ARPREQ     0x0001   // ARP request & response IDs 
.................... #define ARPRESP    0x0002 
....................  
.................... #define PICMP       1       // IP protocol values: ICMP 
.................... #define PTCP        6       //                     TCP 
.................... #define PUDP        17      //                     UDP 
....................  
.................... #define ETHHDR_LEN  6       // Ethernet frame header length 
.................... #define IPHDR_LEN   20      // IP, TCP and ICMP header lengths 
.................... #define TCPHDR_LEN  20 
.................... #define ICMPHDR_LEN 4       // (only include type, code & csum in ICMP hdr) 
.................... #define TCPOPT_LEN  4       // Length of TCP MSS option 
.................... #define TCPSYN_LEN  24      // TCP header length including MSS option   
.................... #define MAXPING_LEN 212     // Max length of Ping data 
....................  
.................... #define TFIN        0x01    // Option flags: no more data 
.................... #define TSYN        0x02    //           sync sequence nums 
.................... #define TRST        0x04    //           reset connection 
.................... #define TPUSH       0x08    //           push buffered data 
.................... #define TACK        0x10    //           acknowledgement 
.................... #define TURGE       0x20    //           urgent 
....................  
.................... #define TCP_MSS     1460    // Max Segment Size for TCP 
....................  
.................... #define ECHOPORT    7       // TCP Port numbers: echo 
.................... #define DAYPORT     13      //                   daytime 
.................... #define HTTPORT     80      //                   HTTP 
....................  
.................... #define DAYMSG      "No daytime msg\r\n" 
.................... #define DAYMSG_LEN  16 
....................  
.................... BYTE ipcol;                 // IP protocol byte 
.................... LWORD myip;                 // My IP adress 
.................... LWORD locip, remip;         // Local & remote IP addresses 
.................... WORD locport, remport;      // ..and TCP port numbers 
.................... LWORD rseq, rack;           // TCP sequence & acknowledge values 
.................... WORD concount;              // Connection count (for high word of my seq num) 
.................... BYTE rflags, tflags;        // Rx and Tx flags 
.................... WORD rpdlen, tpdlen;        // Length of user data in Rx, Tx buffer 
.................... signed long iplen;          // Incoming/outgoing IP length word 
.................... BYTE d_checkhi, d_checklo;  // Checksum value for data 
....................  
.................... BOOL arp_recv(void); 
.................... BOOL ip_recv(void); 
.................... BOOL icmp_recv(void); 
.................... BOOL tcp_recv(void); 
.................... void tcp_handler(void); 
.................... void tcp_xmit(void); 
.................... #separate 
.................... BOOL http_recv(void); 
.................... BOOL ftp_handler(void); 
.................... BOOL daytime_handler(void); 
.................... void put_ip(void); 
.................... void put_tcp(void); 
.................... void add_lword(LWORD &lw, WORD val); 
....................                                         
.................... /* Handle an ARP message */ 
.................... BOOL arp_recv(void) 
.................... { 
*
0BEC:  BSF    03,6
0BED:  BCF    25,0
....................     BOOL ret=0; 
....................      
....................     DEBUG_PUTC('a');                     
....................     if (match_byte(0x00) && match_byte(0x01) &&     // Hardware type 
....................         match_byte(0x08) && match_byte(0x00) &&     // ARP protocol 
....................         match_byte(6) &&  match_byte(4) &&          // Hardware & IP lengths 
....................         match_word(ARPREQ) &&                       // ARP request 
....................         skip_lword() && skip_word() &&              // Sender's MAC addr 
....................         get_lword(remip.l) &&                       // Sender's IP addr 
....................         skip_lword() && skip_word() &&              // Null MAC addr 
....................         match_lword(myip.l))                        // Target IP addr (me?) 
0BEE:  CLRF   36
0BEF:  BCF    03,6
0BF0:  CALL   291
0BF1:  MOVF   78,F
0BF2:  BTFSC  03,2
0BF3:  GOTO   516
0BF4:  MOVLW  01
0BF5:  BSF    03,6
0BF6:  MOVWF  36
0BF7:  BCF    03,6
0BF8:  CALL   291
0BF9:  MOVF   78,F
0BFA:  BTFSC  03,2
0BFB:  GOTO   516
0BFC:  MOVLW  08
0BFD:  BSF    03,6
0BFE:  MOVWF  36
0BFF:  BCF    03,6
0C00:  CALL   291
0C01:  MOVF   78,F
0C02:  BTFSC  03,2
0C03:  GOTO   516
0C04:  BSF    03,6
0C05:  CLRF   36
0C06:  BCF    03,6
0C07:  CALL   291
0C08:  MOVF   78,F
0C09:  BTFSC  03,2
0C0A:  GOTO   516
0C0B:  MOVLW  06
0C0C:  BSF    03,6
0C0D:  MOVWF  36
0C0E:  BCF    03,6
0C0F:  CALL   291
0C10:  MOVF   78,F
0C11:  BTFSC  03,2
0C12:  GOTO   516
0C13:  MOVLW  04
0C14:  BSF    03,6
0C15:  MOVWF  36
0C16:  BCF    03,6
0C17:  CALL   291
0C18:  MOVF   78,F
0C19:  BTFSC  03,2
0C1A:  GOTO   516
0C1B:  BSF    03,6
0C1C:  CLRF   27
0C1D:  MOVLW  01
0C1E:  MOVWF  26
*
0C5A:  MOVF   78,F
0C5B:  BTFSC  03,2
0C5C:  GOTO   516
0C5D:  CALL   2A1
0C5E:  MOVF   78,F
0C5F:  BTFSC  03,2
0C60:  GOTO   516
0C61:  CALL   2AA
0C62:  MOVF   78,F
0C63:  BTFSC  03,2
0C64:  GOTO   516
*
0C75:  MOVF   78,F
0C76:  BTFSC  03,2
0C77:  GOTO   516
0C78:  CALL   2A1
0C79:  MOVF   78,F
0C7A:  BTFSC  03,2
0C7B:  GOTO   516
0C7C:  CALL   2AA
0C7D:  MOVF   78,F
0C7E:  BTFSC  03,2
0C7F:  GOTO   516
*
0CA4:  MOVF   78,F
0CA5:  BTFSC  03,2
0CA6:  GOTO   516
....................     { 
....................         DEBUG_PUTC('>'); 
....................         ret = 1;         
0CA7:  BSF    03,6
0CA8:  BSF    25,0
....................         txin = 0; 
0CA9:  BCF    03,6
0CAA:  CLRF   48
....................         put_word(0x0001);                           // Hardware type 
0CAB:  BSF    03,6
0CAC:  CLRF   39
0CAD:  MOVLW  01
0CAE:  MOVWF  38
0CAF:  BCF    03,6
0CB0:  CALL   2C6
....................         put_word(0x0800);                           // ARP protocol 
0CB1:  MOVLW  08
0CB2:  BSF    03,6
0CB3:  MOVWF  39
0CB4:  CLRF   38
0CB5:  BCF    03,6
0CB6:  CALL   2C6
....................         put_byte(6);                                // Hardware & IP lengths 
0CB7:  MOVLW  06
0CB8:  BSF    03,6
0CB9:  MOVWF  39
0CBA:  BCF    03,6
0CBB:  CALL   2D4
....................         put_byte(4);                                 
0CBC:  MOVLW  04
0CBD:  BSF    03,6
0CBE:  MOVWF  39
0CBF:  BCF    03,6
0CC0:  CALL   2D4
....................         put_word(ARPRESP);                          // ARP response 
0CC1:  BSF    03,6
0CC2:  CLRF   39
0CC3:  MOVLW  02
0CC4:  MOVWF  38
0CC5:  BCF    03,6
0CC6:  CALL   2C6
....................         put_data(myeth, MACLEN);                    // My MAC addr 
0CC7:  MOVLW  00
0CC8:  BSF    03,6
0CC9:  MOVWF  27
0CCA:  MOVLW  2A
0CCB:  MOVWF  26
0CCC:  MOVLW  06
0CCD:  MOVWF  28
0CCE:  BCF    03,6
0CCF:  CALL   2DA
....................         put_lword(myip.l);                          // My IP addr 
....................         put_data(nicin.eth.srce, MACLEN);           // Remote MAC addr 
*
0CE4:  MOVLW  00
0CE5:  BSF    03,6
0CE6:  MOVWF  27
0CE7:  MOVLW  3C
0CE8:  MOVWF  26
0CE9:  MOVLW  06
0CEA:  MOVWF  28
0CEB:  BCF    03,6
0CEC:  CALL   2DA
....................         put_lword(remip.l);                         // Remote IP addr 
....................         put_ether(txbuff, txin);                    // Send to NIC 
*
0D01:  MOVLW  00
0D02:  BSF    03,6
0D03:  MOVWF  39
0D04:  MOVLW  A0
0D05:  MOVWF  38
0D06:  CLRF   3B
0D07:  BCF    03,6
0D08:  MOVF   48,W
0D09:  BSF    03,6
0D0A:  MOVWF  3A
0D0B:  BCF    03,6
0D0C:  CALL   35E
....................         xmit_ether(txin);                           // Transmit 
0D0D:  BSF    03,6
0D0E:  CLRF   39
0D0F:  BCF    03,6
0D10:  MOVF   48,W
0D11:  BSF    03,6
0D12:  MOVWF  38
0D13:  BCF    03,6
0D14:  CALL   3AD
....................         DEBUG_PUTC('A'); 
....................     } 
....................     else 
0D15:  GOTO   517
....................         discard_data(); 
0D16:  CALL   3E7
....................     return(ret); 
0D17:  MOVLW  00
0D18:  BSF    03,6
0D19:  BTFSC  25,0
0D1A:  MOVLW  01
0D1B:  BCF    03,6
0D1C:  MOVWF  78
0D1D:  BCF    0A,3
0D1E:  BSF    0A,4
0D1F:  GOTO   5D3
.................... } 
....................  
.................... /* Get an IP datagram */ 
.................... BOOL ip_recv(void) 
.................... { 
....................     BYTE b, hi, lo; 
....................     int n=0; 
*
1800:  BSF    03,6
1801:  CLRF   28
1802:  BSF    29,0
....................     BOOL ret=1; 
....................  
....................     DEBUG_PUTC('i'); 
....................     checkflag = 0;                                  // Clear checksum 
1803:  BCF    03,6
1804:  BCF    26,2
....................     checkhi = checklo = 0; 
1805:  CLRF   4B
1806:  MOVF   4B,W
1807:  MOVWF  4A
....................     if (match_byte(0x45) && skip_byte() &&          // Version, service 
....................         get_word(iplen) && skip_word() &&           // Len, ID 
....................         skip_word() &&  skip_byte() &&              // Frags, TTL 
....................         get_byte(ipcol) && skip_word() &&           // Protocol, checksum 
....................         get_lword(remip.l) && match_lword(myip.l) && // Addresses 
....................         checkhi==0xff && checklo==0xff)             // Checksum OK? 
1808:  MOVLW  45
1809:  BSF    03,6
180A:  MOVWF  36
180B:  BCF    03,6
180C:  BCF    0A,4
180D:  CALL   291
180E:  BSF    0A,4
180F:  MOVF   78,F
1810:  BTFSC  03,2
1811:  GOTO   4FB
1812:  BCF    0A,4
1813:  CALL   520
1814:  BSF    0A,4
1815:  MOVF   78,F
1816:  BTFSC  03,2
1817:  GOTO   4FB
*
183F:  MOVF   78,F
1840:  BTFSC  03,2
1841:  GOTO   4FB
1842:  BCF    0A,4
1843:  CALL   2AA
1844:  BSF    0A,4
1845:  MOVF   78,F
1846:  BTFSC  03,2
1847:  GOTO   4FB
1848:  BCF    0A,4
1849:  CALL   2AA
184A:  BSF    0A,4
184B:  MOVF   78,F
184C:  BTFSC  03,2
184D:  GOTO   4FB
184E:  BCF    0A,4
184F:  CALL   520
1850:  BSF    0A,4
1851:  MOVF   78,F
1852:  BTFSC  03,2
1853:  GOTO   4FB
*
1863:  MOVF   78,F
1864:  BTFSC  03,2
1865:  GOTO   4FB
1866:  BCF    0A,4
1867:  CALL   2AA
1868:  BSF    0A,4
1869:  MOVF   78,F
186A:  BTFSC  03,2
186B:  GOTO   4FB
*
1884:  MOVF   78,F
1885:  BTFSC  03,2
1886:  GOTO   4FB
*
18B3:  MOVF   78,F
18B4:  BTFSC  03,2
18B5:  GOTO   4FB
18B6:  INCF   4A,W
18B7:  BTFSS  03,2
18B8:  GOTO   4FB
18B9:  INCF   4B,W
18BA:  BTFSS  03,2
18BB:  GOTO   4FB
....................     {  
....................         DEBUG_PUTC('>'); 
....................         if (ipcol == PICMP)                         // ICMP? 
18BC:  MOVLW  01
18BD:  SUBWF  4D,W
18BE:  BTFSS  03,2
18BF:  GOTO   1D8
....................             icmp_recv();                            // Call ping handler 
....................         else if (ipcol == PTCP)                     // TCP segment? 
*
19D7:  GOTO   4FA
19D8:  MOVLW  06
19D9:  SUBWF  4D,W
19DA:  BTFSS  03,2
19DB:  GOTO   4F7
....................             tcp_recv();                             // Call TCP handler 
....................         else 
*
1CF6:  GOTO   4FA
....................             discard_data();                         // Unknown; discard it 
1CF7:  BCF    0A,4
1CF8:  CALL   3E7
1CF9:  BSF    0A,4
....................     } 
....................     else 
1CFA:  GOTO   4FE
....................         discard_data(); 
1CFB:  BCF    0A,4
1CFC:  CALL   3E7
1CFD:  BSF    0A,4
....................     return(ret); 
1CFE:  MOVLW  00
1CFF:  BSF    03,6
1D00:  BTFSC  29,0
1D01:  MOVLW  01
1D02:  BCF    03,6
1D03:  MOVWF  78
1D04:  BCF    0A,3
1D05:  BSF    0A,4
1D06:  GOTO   5DF
.................... } 
....................  
.................... /* Respond to an ICMP message (e.g. ping) */ 
.................... BOOL icmp_recv(void) 
.................... { 
....................     BOOL ret=0; 
*
18C0:  BSF    03,6
18C1:  BCF    2A,0
....................     WORD csum; 
....................  
....................     DEBUG_PUTC('c'); 
....................     rpdlen = 0; 
18C2:  BCF    03,6
18C3:  CLRF   6B
18C4:  CLRF   6A
....................     if (match_byte(8) && match_byte(0) && get_word(csum)) 
18C5:  MOVLW  08
18C6:  BSF    03,6
18C7:  MOVWF  36
18C8:  BCF    03,6
18C9:  BCF    0A,4
18CA:  CALL   291
18CB:  BSF    0A,4
18CC:  MOVF   78,F
18CD:  BTFSC  03,2
18CE:  GOTO   1D1
18CF:  BSF    03,6
18D0:  CLRF   36
18D1:  BCF    03,6
18D2:  BCF    0A,4
18D3:  CALL   291
18D4:  BSF    0A,4
18D5:  MOVF   78,F
18D6:  BTFSC  03,2
18D7:  GOTO   1D1
*
18FF:  MOVF   78,F
1900:  BTFSC  03,2
1901:  GOTO   1D1
....................     { 
....................         while (skip_byte())                 // Check data 
1902:  BCF    0A,4
1903:  CALL   520
1904:  BSF    0A,4
1905:  MOVF   78,F
1906:  BTFSC  03,2
1907:  GOTO   10C
....................             rpdlen++; 
1908:  INCF   6A,F
1909:  BTFSC  03,2
190A:  INCF   6B,F
190B:  GOTO   102
....................         ret = (checkhi==0xff) && (checklo==0xff); 
190C:  INCF   4A,W
190D:  BTFSS  03,2
190E:  GOTO   112
190F:  INCF   4B,W
1910:  BTFSC  03,2
1911:  GOTO   116
1912:  BSF    03,6
1913:  BCF    2A,0
1914:  BCF    03,6
1915:  GOTO   119
1916:  BSF    03,6
1917:  BSF    2A,0
1918:  BCF    03,6
....................         if (ret && rpdlen<=MAXPING_LEN)  
1919:  BSF    03,6
191A:  BTFSC  2A,0
191B:  GOTO   11E
191C:  BCF    03,6
191D:  GOTO   1D1
191E:  BCF    03,6
191F:  MOVF   6B,F
1920:  BTFSS  03,2
1921:  GOTO   1D1
1922:  MOVLW  D5
1923:  SUBWF  6A,W
1924:  BTFSC  03,0
1925:  GOTO   1D1
....................         {                                   // If OK and not bcast.. 
....................             DEBUG_PUTC('>'); 
....................             checkhi = checklo = 0;          // Clear checksum 
1926:  CLRF   4B
1927:  MOVF   4B,W
1928:  MOVWF  4A
....................             put_ip();                       // IP header 
1929:  BCF    0A,4
192A:  CALL   526
192B:  BSF    0A,4
....................             put_word(0);                    // ICMP type and code 
192C:  BSF    03,6
192D:  CLRF   39
192E:  CLRF   38
192F:  BCF    03,6
1930:  BCF    0A,4
1931:  CALL   2C6
1932:  BSF    0A,4
....................             csum += 0x0800;                 // Adjust checksum for resp 
1933:  MOVLW  00
1934:  BSF    03,6
1935:  ADDWF  2B,F
1936:  MOVLW  08
1937:  BTFSC  03,0
1938:  ADDLW  01
1939:  ADDWF  2C,F
....................             if (csum < 0x0800)              // ..including hi-lo carry 
193A:  MOVLW  08
193B:  SUBWF  2C,W
193C:  BTFSS  03,0
193D:  GOTO   140
193E:  BCF    03,6
193F:  GOTO   146
1940:  BCF    03,6
....................                 csum++; 
1941:  BSF    03,6
1942:  INCF   2B,F
1943:  BTFSC  03,2
1944:  INCF   2C,F
1945:  BCF    03,6
....................             put_word(csum);                 // ICMP checksum 
1946:  BSF    03,6
1947:  MOVF   2C,W
1948:  MOVWF  39
1949:  MOVF   2B,W
194A:  MOVWF  38
194B:  BCF    03,6
194C:  BCF    0A,4
194D:  CALL   2C6
194E:  BSF    0A,4
....................             put_ether(txbuff, txin);        // Send ICMP response 
194F:  MOVLW  00
1950:  BSF    03,6
1951:  MOVWF  39
1952:  MOVLW  A0
1953:  MOVWF  38
1954:  CLRF   3B
1955:  BCF    03,6
1956:  MOVF   48,W
1957:  BSF    03,6
1958:  MOVWF  3A
1959:  BCF    03,6
195A:  BCF    0A,4
195B:  CALL   35E
195C:  BSF    0A,4
....................             copy_rx_tx(txin, IPHDR_LEN+ICMPHDR_LEN, rpdlen); 
195D:  MOVF   48,W
195E:  BSF    03,6
195F:  MOVWF  2D
1960:  MOVLW  18
1961:  MOVWF  2E
1962:  BCF    03,6
1963:  MOVF   6A,W
1964:  BSF    03,6
1965:  MOVWF  2F
....................             xmit_ether(IPHDR_LEN+ICMPHDR_LEN+rpdlen); 
*
19BE:  MOVLW  18
19BF:  ADDWF  6A,W
19C0:  BSF    03,6
19C1:  MOVWF  2D
19C2:  MOVLW  00
19C3:  BTFSC  03,0
19C4:  ADDLW  01
19C5:  BCF    03,6
19C6:  ADDWF  6B,W
19C7:  BSF    03,6
19C8:  MOVWF  2E
19C9:  MOVF   2E,W
19CA:  MOVWF  39
19CB:  MOVF   2D,W
19CC:  MOVWF  38
19CD:  BCF    03,6
19CE:  BCF    0A,4
19CF:  CALL   3AD
19D0:  BSF    0A,4
....................             DEBUG_PUTC('I'); 
....................         } 
....................     } 
....................     return(ret); 
19D1:  MOVLW  00
19D2:  BSF    03,6
19D3:  BTFSC  2A,0
19D4:  MOVLW  01
19D5:  BCF    03,6
19D6:  MOVWF  78
.................... } 
....................  
.................... /* Respond to an TCP segment */ 
.................... BOOL tcp_recv(void) 
.................... { 
....................     int hlen, n; 
....................     BOOL ret=0; 
*
19DC:  BSF    03,6
19DD:  BCF    2C,0
....................     WORD addr; 
....................  
....................     checkhi = checklo = 0; 
19DE:  BCF    03,6
19DF:  CLRF   4B
19E0:  MOVF   4B,W
19E1:  MOVWF  4A
....................     DEBUG_PUTC('t'); 
....................     if (get_word(remport) && get_word(locport) &&   // Source & dest ports 
....................         get_lword(rseq.l) && get_lword(rack.l) &&   // Seq & ack numbers 
....................         get_byte(hlen) && get_byte(rflags) &&       // Header len & flags 
....................         skip_word() && skip_lword())                // Window, csum, urgent ptr 
*
1A09:  MOVF   78,F
1A0A:  BTFSC  03,2
1A0B:  GOTO   4F0
*
1A33:  MOVF   78,F
1A34:  BTFSC  03,2
1A35:  GOTO   4F0
*
1A4E:  MOVF   78,F
1A4F:  BTFSC  03,2
1A50:  GOTO   4F0
*
1A69:  MOVF   78,F
1A6A:  BTFSC  03,2
1A6B:  GOTO   4F0
*
1A7F:  MOVF   78,F
1A80:  BTFSC  03,2
1A81:  GOTO   4F0
*
1A91:  MOVF   78,F
1A92:  BTFSC  03,2
1A93:  GOTO   4F0
1A94:  BCF    0A,4
1A95:  CALL   2AA
1A96:  BSF    0A,4
1A97:  MOVF   78,F
1A98:  BTFSC  03,2
1A99:  GOTO   4F0
1A9A:  BCF    0A,4
1A9B:  CALL   2A1
1A9C:  BSF    0A,4
1A9D:  MOVF   78,F
1A9E:  BTFSC  03,2
1A9F:  GOTO   4F0
....................     { 
....................         DEBUG_PUTC('>'); 
....................         iplen -= IPHDR_LEN;                         // Get TCP segment length 
1AA0:  MOVLW  14
1AA1:  SUBWF  6E,F
1AA2:  MOVLW  00
1AA3:  BTFSS  03,0
1AA4:  DECF   6F,F
1AA5:  SUBWF  6F,F
....................         check_word(iplen);                          // Check pseudoheader 
1AA6:  MOVF   6F,W
1AA7:  BSF    03,6
1AA8:  MOVWF  39
1AA9:  BCF    03,6
1AAA:  MOVF   6E,W
1AAB:  BSF    03,6
1AAC:  MOVWF  38
1AAD:  BCF    03,6
1AAE:  BCF    0A,4
1AAF:  CALL   5DA
1AB0:  BSF    0A,4
....................         check_lword(myip.l); 
....................         check_lword(remip.l); 
....................         check_byte(0); 
*
1AE9:  BSF    03,6
1AEA:  CLRF   3E
1AEB:  BCF    03,6
1AEC:  BCF    0A,4
1AED:  CALL   249
1AEE:  BSF    0A,4
....................         check_byte(PTCP); 
1AEF:  MOVLW  06
1AF0:  BSF    03,6
1AF1:  MOVWF  3E
1AF2:  BCF    03,6
1AF3:  BCF    0A,4
1AF4:  CALL   249
1AF5:  BSF    0A,4
....................         rxout = (hlen>>2) + IPHDR_LEN;              // Skip over options 
1AF6:  BSF    03,6
1AF7:  MOVF   2A,W
1AF8:  BCF    03,6
1AF9:  MOVWF  77
1AFA:  RRF    77,F
1AFB:  RRF    77,F
1AFC:  MOVLW  3F
1AFD:  ANDWF  77,F
1AFE:  MOVF   77,W
1AFF:  MOVWF  77
1B00:  MOVLW  14
1B01:  ADDWF  77,W
1B02:  MOVWF  46
1B03:  CLRF   47
1B04:  BTFSC  03,0
1B05:  INCF   47,F
....................         rpdlen = iplen - rxout + IPHDR_LEN;  
1B06:  MOVF   6E,W
1B07:  BSF    03,6
1B08:  MOVWF  2F
1B09:  BCF    03,6
1B0A:  MOVF   46,W
1B0B:  BSF    03,6
1B0C:  SUBWF  2F,F
1B0D:  BCF    03,6
1B0E:  MOVF   6F,W
1B0F:  BSF    03,6
1B10:  MOVWF  30
1B11:  BCF    03,6
1B12:  MOVF   47,W
1B13:  BTFSC  03,0
1B14:  GOTO   318
1B15:  BSF    03,6
1B16:  DECF   30,F
1B17:  BCF    03,6
1B18:  BSF    03,6
1B19:  SUBWF  30,F
1B1A:  MOVLW  14
1B1B:  ADDWF  2F,W
1B1C:  BCF    03,6
1B1D:  MOVWF  6A
1B1E:  MOVLW  00
1B1F:  BTFSC  03,0
1B20:  ADDLW  01
1B21:  BSF    03,6
1B22:  ADDWF  30,W
1B23:  BCF    03,6
1B24:  MOVWF  6B
....................         addr = getnic_addr(); 
*
1B53:  MOVF   79,W
1B54:  BSF    03,6
1B55:  MOVWF  2E
1B56:  BCF    03,6
1B57:  MOVF   78,W
1B58:  BSF    03,6
1B59:  MOVWF  2D
....................         check_rxbytes(IPHDR_LEN+TCPHDR_LEN, iplen-TCPHDR_LEN); 
1B5A:  BCF    03,6
1B5B:  MOVF   6E,W
1B5C:  BSF    03,6
1B5D:  MOVWF  2F
1B5E:  MOVLW  14
1B5F:  SUBWF  2F,F
1B60:  BCF    03,6
1B61:  MOVF   6F,W
1B62:  BSF    03,6
1B63:  MOVWF  30
1B64:  MOVLW  00
1B65:  BTFSS  03,0
1B66:  DECF   30,F
1B67:  SUBWF  30,F
1B68:  MOVLW  28
1B69:  MOVWF  31
1B6A:  MOVF   30,W
1B6B:  MOVWF  33
1B6C:  MOVF   2F,W
1B6D:  MOVWF  32
....................         setnic_addr(addr); 
*
1BBB:  BSF    03,6
1BBC:  MOVF   2E,W
1BBD:  MOVWF  3D
1BBE:  MOVF   2D,W
1BBF:  MOVWF  3C
1BC0:  BCF    03,6
1BC1:  BCF    0A,4
1BC2:  CALL   063
1BC3:  BSF    0A,4
....................         ret = (checkhi==0xff) && (checklo==0xff); 
1BC4:  INCF   4A,W
1BC5:  BTFSS  03,2
1BC6:  GOTO   3CA
1BC7:  INCF   4B,W
1BC8:  BTFSC  03,2
1BC9:  GOTO   3CE
1BCA:  BSF    03,6
1BCB:  BCF    2C,0
1BCC:  BCF    03,6
1BCD:  GOTO   3D1
1BCE:  BSF    03,6
1BCF:  BSF    2C,0
1BD0:  BCF    03,6
....................         if (ret) 
1BD1:  BSF    03,6
1BD2:  BTFSC  2C,0
1BD3:  GOTO   3D6
1BD4:  BCF    03,6
1BD5:  GOTO   4EF
1BD6:  BCF    03,6
....................             tcp_handler(); 
....................     } 
....................     else 
*
1CEF:  GOTO   4F0
....................         DEBUG_PUTC('!'); 
....................     return(ret); 
1CF0:  MOVLW  00
1CF1:  BSF    03,6
1CF2:  BTFSC  2C,0
1CF3:  MOVLW  01
1CF4:  BCF    03,6
1CF5:  MOVWF  78
.................... } 
....................  
.................... /* Handle an incoming TCP segment */ 
.................... void tcp_handler(void) 
.................... { 
*
1BD7:  BSF    03,6
1BD8:  BSF    2F,0
....................     BOOL tx=1;                          // Set transmission flag 
....................  
....................     tpdlen = tpxdlen = 0;               // Assume no Tx data  
1BD9:  BCF    03,6
1BDA:  CLRF   29
1BDB:  CLRF   28
1BDC:  MOVF   29,W
1BDD:  MOVWF  6D
1BDE:  MOVF   28,W
1BDF:  MOVWF  6C
....................     d_checkhi = d_checklo = 0; 
1BE0:  CLRF   71
1BE1:  MOVF   71,W
1BE2:  MOVWF  70
....................     checkflag = 0; 
1BE3:  BCF    26,2
....................     tflags = TACK;                      // ..and just sending an ack 
1BE4:  MOVLW  10
1BE5:  MOVWF  69
....................     if (rflags & TRST)      		// RESET received? 
1BE6:  MOVF   68,W
1BE7:  ANDLW  04
1BE8:  IORLW  00
1BE9:  BTFSC  03,2
1BEA:  GOTO   3EF
....................         tx = 0;                         //..do nothing 
1BEB:  BSF    03,6
1BEC:  BCF    2F,0
....................     else if (rflags & TSYN)             // SYN received? 
1BED:  BCF    03,6
1BEE:  GOTO   4E6
1BEF:  MOVF   68,W
1BF0:  ANDLW  02
1BF1:  IORLW  00
1BF2:  BTFSC  03,2
1BF3:  GOTO   437
....................     { 
....................         add_lword(rseq.l, 1);           // Adjust Tx ack for SYN 
1BF4:  BSF    03,6
1BF5:  CLRF   33
1BF6:  MOVLW  01
1BF7:  MOVWF  32
.................... #if INCLUDE_DAYTIME         
....................         if (locport==DAYPORT || locport==HTTPORT) 
.................... #else         
*
1C16:  MOVF   5B,F
1C17:  BTFSS  03,2
1C18:  GOTO   41D
1C19:  MOVLW  0D
1C1A:  SUBWF  5A,W
1C1B:  BTFSC  03,2
1C1C:  GOTO   424
1C1D:  MOVF   5B,F
1C1E:  BTFSS  03,2
1C1F:  GOTO   434
1C20:  MOVLW  50
1C21:  SUBWF  5A,W
1C22:  BTFSS  03,2
1C23:  GOTO   434
....................         if (locport==HTTPORT) 
.................... #endif         
....................         {                               // Recognised port? 
....................             rack.w[0] = 0xffff; 
1C24:  MOVLW  FF
1C25:  MOVWF  63
1C26:  MOVLW  FF
1C27:  MOVWF  62
....................             rack.w[1] = concount++; 
1C28:  MOVF   67,W
1C29:  MOVWF  7A
1C2A:  MOVF   66,W
1C2B:  INCF   66,F
1C2C:  BTFSC  03,2
1C2D:  INCF   67,F
1C2E:  MOVWF  64
1C2F:  MOVF   7A,W
1C30:  MOVWF  65
....................             tflags = TSYN+TACK;         // Send SYN ACK 
1C31:  MOVLW  12
1C32:  MOVWF  69
....................         } 
....................         else                            // Unrecognised port? 
1C33:  GOTO   436
....................             tflags = TRST+TACK;         // Send reset 
1C34:  MOVLW  14
1C35:  MOVWF  69
....................     } 
....................     else if (rflags & TFIN)             // Received FIN? 
1C36:  GOTO   4E6
1C37:  MOVF   68,W
1C38:  ANDLW  01
1C39:  IORLW  00
1C3A:  BTFSC  03,2
1C3B:  GOTO   46A
....................         add_lword(rseq.l, rpdlen+1);    // Ack all incoming data + FIN 
1C3C:  MOVLW  01
1C3D:  ADDWF  6A,W
1C3E:  BSF    03,6
1C3F:  MOVWF  30
1C40:  MOVLW  00
1C41:  BTFSC  03,0
1C42:  ADDLW  01
1C43:  BCF    03,6
1C44:  ADDWF  6B,W
1C45:  BSF    03,6
1C46:  MOVWF  31
1C47:  MOVF   31,W
1C48:  MOVWF  33
1C49:  MOVF   30,W
1C4A:  MOVWF  32
....................     else if (rflags & TACK)             // ACK received? 
*
1C69:  GOTO   4E6
1C6A:  MOVF   68,W
1C6B:  ANDLW  10
1C6C:  IORLW  00
1C6D:  BTFSC  03,2
1C6E:  GOTO   4E6
....................     { 
....................         if (rpdlen)                     // Adjust Tx ack for Rx data 
1C6F:  MOVF   6A,W
1C70:  IORWF  6B,W
1C71:  BTFSC  03,2
1C72:  GOTO   499
....................             add_lword(rseq.l, rpdlen); 
1C73:  MOVF   6B,W
1C74:  BSF    03,6
1C75:  MOVWF  33
1C76:  BCF    03,6
1C77:  MOVF   6A,W
1C78:  BSF    03,6
1C79:  MOVWF  32
....................         else                            // If no data, don't send ack 
*
1C98:  GOTO   49C
....................             tx = 0; 
1C99:  BSF    03,6
1C9A:  BCF    2F,0
1C9B:  BCF    03,6
....................         if (locport==HTTPORT && rpdlen) 
1C9C:  MOVF   5B,F
1C9D:  BTFSS  03,2
1C9E:  GOTO   4AE
1C9F:  MOVLW  50
1CA0:  SUBWF  5A,W
1CA1:  BTFSS  03,2
1CA2:  GOTO   4AE
1CA3:  MOVF   6A,W
1CA4:  IORWF  6B,W
1CA5:  BTFSC  03,2
1CA6:  GOTO   4AE
....................         {                               // HTTP 'get' method? 
....................             http_recv();                // Call handler.. 
1CA7:  BCF    0A,3
1CA8:  GOTO   208
1CA9:  BSF    0A,3
....................             tx = 0;                     // ..which does its own Tx 
1CAA:  BSF    03,6
1CAB:  BCF    2F,0
....................         } 
.................... #if INCLUDE_DAYTIME 
....................         else if (locport==DAYPORT && rack.w[0]==0) 
1CAC:  BCF    03,6
1CAD:  GOTO   4E6
1CAE:  MOVF   5B,F
1CAF:  BTFSS  03,2
1CB0:  GOTO   4E6
1CB1:  MOVLW  0D
1CB2:  SUBWF  5A,W
1CB3:  BTFSS  03,2
1CB4:  GOTO   4E6
1CB5:  MOVF   63,F
1CB6:  BTFSS  03,2
1CB7:  GOTO   4E6
1CB8:  MOVF   62,F
1CB9:  BTFSS  03,2
1CBA:  GOTO   4E6
....................         {                               // Daytime request? 
....................             daytime_handler();          // Prepare daytime data 
....................             tx = 1;                     // ..and send it 
*
1CE3:  BSF    03,6
1CE4:  BSF    2F,0
1CE5:  BCF    03,6
....................         } 
.................... #endif         
....................     } 
....................     if (tx)                             // If transmission required 
1CE6:  BSF    03,6
1CE7:  BTFSC  2F,0
1CE8:  GOTO   4EB
1CE9:  BCF    03,6
1CEA:  GOTO   4EF
1CEB:  BCF    03,6
....................         tcp_xmit();                     // ..do it 
1CEC:  BCF    0A,3
1CED:  CALL   000
1CEE:  BSF    0A,3
.................... } 
....................  
.................... /* Transmit a TCP segment */ 
.................... void tcp_xmit(void) 
.................... { 
....................     iplen = tpdlen + tpxdlen + IPHDR_LEN + TCPHDR_LEN; 
*
1000:  MOVF   6C,W
1001:  ADDWF  28,W
1002:  BSF    03,6
1003:  MOVWF  36
1004:  BCF    03,6
1005:  MOVF   6D,W
1006:  BTFSC  03,0
1007:  ADDLW  01
1008:  ADDWF  29,W
1009:  BSF    03,6
100A:  MOVWF  37
100B:  MOVLW  14
100C:  ADDWF  36,F
100D:  MOVLW  00
100E:  BTFSC  03,0
100F:  ADDLW  01
1010:  ADDWF  37,F
1011:  MOVLW  14
1012:  ADDWF  36,W
1013:  BCF    03,6
1014:  MOVWF  6E
1015:  MOVLW  00
1016:  BTFSC  03,0
1017:  ADDLW  01
1018:  BSF    03,6
1019:  ADDWF  37,W
101A:  BCF    03,6
101B:  MOVWF  6F
....................     if (tflags & TSYN)                  // If SYN, allow for MSS option 
101C:  MOVF   69,W
101D:  ANDLW  02
101E:  IORLW  00
101F:  BTFSC  03,2
1020:  GOTO   027
....................         iplen += TCPOPT_LEN; 
1021:  MOVLW  04
1022:  ADDWF  6E,F
1023:  MOVLW  00
1024:  BTFSC  03,0
1025:  ADDLW  01
1026:  ADDWF  6F,F
....................     put_ip();                           // IP header 
1027:  BCF    0A,4
1028:  BSF    0A,3
1029:  CALL   526
102A:  BSF    0A,4
102B:  BCF    0A,3
....................     put_tcp();                          // TCP header 
....................     put_ether(txbuff, txin+tpdlen);     // Send to NIC 
*
118C:  MOVF   48,W
118D:  ADDWF  6C,W
118E:  BSF    03,6
118F:  MOVWF  36
1190:  BCF    03,6
1191:  MOVF   6D,W
1192:  BSF    03,6
1193:  MOVWF  37
1194:  BTFSC  03,0
1195:  INCF   37,F
1196:  MOVLW  00
1197:  MOVWF  39
1198:  MOVLW  A0
1199:  MOVWF  38
119A:  MOVF   37,W
119B:  MOVWF  3B
119C:  MOVF   36,W
119D:  MOVWF  3A
119E:  BCF    03,6
119F:  BCF    0A,4
11A0:  BSF    0A,3
11A1:  CALL   35E
11A2:  BSF    0A,4
11A3:  BCF    0A,3
....................     xmit_ether(txin+tpdlen+tpxdlen);    // Transmit 
11A4:  MOVF   48,W
11A5:  ADDWF  6C,W
11A6:  BSF    03,6
11A7:  MOVWF  36
11A8:  BCF    03,6
11A9:  MOVF   6D,W
11AA:  BSF    03,6
11AB:  MOVWF  37
11AC:  BTFSC  03,0
11AD:  INCF   37,F
11AE:  BCF    03,6
11AF:  MOVF   28,W
11B0:  BSF    03,6
11B1:  ADDWF  36,F
11B2:  BCF    03,6
11B3:  MOVF   29,W
11B4:  BTFSC  03,0
11B5:  ADDLW  01
11B6:  BSF    03,6
11B7:  ADDWF  37,F
11B8:  MOVF   37,W
11B9:  MOVWF  39
11BA:  MOVF   36,W
11BB:  MOVWF  38
11BC:  BCF    03,6
11BD:  BCF    0A,4
11BE:  BSF    0A,3
11BF:  CALL   3AD
11C0:  BSF    0A,4
11C1:  BCF    0A,3
11C2:  RETLW  00
....................     DEBUG_PUTC('T'); 
.................... } 
....................  
.................... /* Respond to an Daytime request */ 
.................... BOOL daytime_handler(void) 
.................... { 
....................     checkhi = checklo = 0; 
*
1CBB:  CLRF   4B
1CBC:  MOVF   4B,W
1CBD:  MOVWF  4A
....................     txin = IPHDR_LEN + TCPHDR_LEN;      // O/P data to buffer, calc checksum 
1CBE:  MOVLW  28
1CBF:  MOVWF  48
....................     printf(put_byte, DAYMSG); 
*
0050:  BCF    0A,0
0051:  BCF    0A,1
0052:  BCF    0A,2
0053:  ADDWF  02,F
0054:  RETLW  4E
0055:  RETLW  6F
0056:  RETLW  20
0057:  RETLW  64
0058:  RETLW  61
0059:  RETLW  79
005A:  RETLW  74
005B:  RETLW  69
005C:  RETLW  6D
005D:  RETLW  65
005E:  RETLW  20
005F:  RETLW  6D
0060:  RETLW  73
0061:  RETLW  67
0062:  RETLW  0D
0063:  RETLW  0A
0064:  RETLW  00
*
1CC0:  BSF    03,6
1CC1:  CLRF   30
1CC2:  BCF    03,6
1CC3:  BSF    03,6
1CC4:  MOVF   30,W
1CC5:  BCF    03,6
1CC6:  BCF    0A,4
1CC7:  BCF    0A,3
1CC8:  CALL   050
1CC9:  BSF    0A,4
1CCA:  BSF    0A,3
1CCB:  BSF    03,6
1CCC:  INCF   30,F
1CCD:  MOVWF  39
1CCE:  BCF    03,6
1CCF:  BCF    0A,4
1CD0:  CALL   2D4
1CD1:  BSF    0A,4
1CD2:  MOVLW  10
1CD3:  BSF    03,6
1CD4:  SUBWF  30,W
1CD5:  BTFSC  03,2
1CD6:  GOTO   4D9
1CD7:  BCF    03,6
1CD8:  GOTO   4C3
....................     tpdlen = DAYMSG_LEN;                // Data length of response 
1CD9:  BCF    03,6
1CDA:  CLRF   6D
1CDB:  MOVLW  10
1CDC:  MOVWF  6C
....................     d_checkhi = checkhi;                // Save checksum 
1CDD:  MOVF   4A,W
1CDE:  MOVWF  70
....................     d_checklo = checklo; 
1CDF:  MOVF   4B,W
1CE0:  MOVWF  71
....................     tflags = TFIN+TACK;                 // Ack & close connection 
1CE1:  MOVLW  11
1CE2:  MOVWF  69
.................... } 
....................  
.................... /* Put out a TCP segment. Data checksum must have already been computed */ 
.................... void put_tcp(void) 
.................... { 
....................     WORD len; 
....................  
....................     checkflag = 0;                  // Ensure we're on an even byte 
*
102C:  BCF    26,2
....................     checkhi = d_checkhi;            // Retrieve data checksum 
102D:  MOVF   70,W
102E:  MOVWF  4A
....................     checklo = d_checklo; 
102F:  MOVF   71,W
1030:  MOVWF  4B
....................     put_word(locport);              // Local and remote ports 
1031:  MOVF   5B,W
1032:  BSF    03,6
1033:  MOVWF  39
1034:  BCF    03,6
1035:  MOVF   5A,W
1036:  BSF    03,6
1037:  MOVWF  38
1038:  BCF    03,6
1039:  BCF    0A,4
103A:  BSF    0A,3
103B:  CALL   2C6
103C:  BSF    0A,4
103D:  BCF    0A,3
....................     put_word(remport); 
103E:  MOVF   5D,W
103F:  BSF    03,6
1040:  MOVWF  39
1041:  BCF    03,6
1042:  MOVF   5C,W
1043:  BSF    03,6
1044:  MOVWF  38
1045:  BCF    03,6
1046:  BCF    0A,4
1047:  BSF    0A,3
1048:  CALL   2C6
1049:  BSF    0A,4
104A:  BCF    0A,3
....................     put_lword(rack.l);              // Seq & ack numbers 
....................     put_lword(rseq.l); 
....................     put_byte(tflags&TSYN ? TCPSYN_LEN*4 : TCPHDR_LEN*4);   // Header len 
*
1093:  MOVF   69,W
1094:  ANDLW  02
1095:  IORLW  00
1096:  BTFSC  03,2
1097:  GOTO   09A
1098:  MOVLW  60
1099:  GOTO   09B
109A:  MOVLW  50
109B:  BSF    03,6
109C:  MOVWF  38
109D:  MOVF   38,W
109E:  MOVWF  39
109F:  BCF    03,6
10A0:  BCF    0A,4
10A1:  BSF    0A,3
10A2:  CALL   2D4
10A3:  BSF    0A,4
10A4:  BCF    0A,3
....................     put_byte(tflags); 
10A5:  MOVF   69,W
10A6:  BSF    03,6
10A7:  MOVWF  39
10A8:  BCF    03,6
10A9:  BCF    0A,4
10AA:  BSF    0A,3
10AB:  CALL   2D4
10AC:  BSF    0A,4
10AD:  BCF    0A,3
....................     put_byte(0x0b);                 // Window size word 
10AE:  MOVLW  0B
10AF:  BSF    03,6
10B0:  MOVWF  39
10B1:  BCF    03,6
10B2:  BCF    0A,4
10B3:  BSF    0A,3
10B4:  CALL   2D4
10B5:  BSF    0A,4
10B6:  BCF    0A,3
....................     put_byte(0xb8); 
10B7:  MOVLW  B8
10B8:  BSF    03,6
10B9:  MOVWF  39
10BA:  BCF    03,6
10BB:  BCF    0A,4
10BC:  BSF    0A,3
10BD:  CALL   2D4
10BE:  BSF    0A,4
10BF:  BCF    0A,3
....................     len = tpdlen + tpxdlen + TCPHDR_LEN; 
10C0:  MOVF   6C,W
10C1:  ADDWF  28,W
10C2:  BSF    03,6
10C3:  MOVWF  38
10C4:  BCF    03,6
10C5:  MOVF   6D,W
10C6:  BTFSC  03,0
10C7:  ADDLW  01
10C8:  ADDWF  29,W
10C9:  BSF    03,6
10CA:  MOVWF  39
10CB:  MOVLW  14
10CC:  ADDWF  38,W
10CD:  MOVWF  36
10CE:  MOVLW  00
10CF:  BTFSC  03,0
10D0:  ADDLW  01
10D1:  ADDWF  39,W
10D2:  MOVWF  37
....................     if (tflags & TSYN)              // If sending SYN, send MSS option 
10D3:  BCF    03,6
10D4:  MOVF   69,W
10D5:  ANDLW  02
10D6:  IORLW  00
10D7:  BTFSC  03,2
10D8:  GOTO   100
....................     { 
....................         txin += 4;                  // Put MSS in buffer after TCP header 
10D9:  MOVLW  04
10DA:  ADDWF  48,F
....................         len += TCPOPT_LEN; 
10DB:  MOVLW  04
10DC:  BSF    03,6
10DD:  ADDWF  36,F
10DE:  MOVLW  00
10DF:  BTFSC  03,0
10E0:  ADDLW  01
10E1:  ADDWF  37,F
....................         put_byte(2); 
10E2:  MOVLW  02
10E3:  MOVWF  39
10E4:  BCF    03,6
10E5:  BCF    0A,4
10E6:  BSF    0A,3
10E7:  CALL   2D4
10E8:  BSF    0A,4
10E9:  BCF    0A,3
....................         put_byte(4); 
10EA:  MOVLW  04
10EB:  BSF    03,6
10EC:  MOVWF  39
10ED:  BCF    03,6
10EE:  BCF    0A,4
10EF:  BSF    0A,3
10F0:  CALL   2D4
10F1:  BSF    0A,4
10F2:  BCF    0A,3
....................         put_word(TCP_MSS); 
10F3:  MOVLW  05
10F4:  BSF    03,6
10F5:  MOVWF  39
10F6:  MOVLW  B4
10F7:  MOVWF  38
10F8:  BCF    03,6
10F9:  BCF    0A,4
10FA:  BSF    0A,3
10FB:  CALL   2C6
10FC:  BSF    0A,4
10FD:  BCF    0A,3
....................         txin -= TCPOPT_LEN + 4;     // Go back to checksum in header 
10FE:  MOVLW  08
10FF:  SUBWF  48,F
....................     } 
....................     check_lword(myip.l);            // Add pseudoheader to checksum 
....................     check_lword(remip.l); 
....................     check_byte(0); 
*
1148:  BSF    03,6
1149:  CLRF   3E
114A:  BCF    03,6
114B:  BCF    0A,4
114C:  BSF    0A,3
114D:  CALL   249
114E:  BSF    0A,4
114F:  BCF    0A,3
....................     check_byte(PTCP); 
1150:  MOVLW  06
1151:  BSF    03,6
1152:  MOVWF  3E
1153:  BCF    03,6
1154:  BCF    0A,4
1155:  BSF    0A,3
1156:  CALL   249
1157:  BSF    0A,4
1158:  BCF    0A,3
....................     check_word(len); 
1159:  BSF    03,6
115A:  MOVF   37,W
115B:  MOVWF  39
115C:  MOVF   36,W
115D:  MOVWF  38
115E:  BCF    03,6
115F:  BCF    0A,4
1160:  BSF    0A,3
1161:  CALL   5DA
1162:  BSF    0A,4
1163:  BCF    0A,3
....................     put_byte(~checkhi);             // Send checksum 
1164:  MOVF   4A,W
1165:  BSF    03,6
1166:  MOVWF  38
1167:  COMF   38,F
1168:  MOVF   38,W
1169:  MOVWF  39
116A:  BCF    03,6
116B:  BCF    0A,4
116C:  BSF    0A,3
116D:  CALL   2D4
116E:  BSF    0A,4
116F:  BCF    0A,3
....................     put_byte(~checklo); 
1170:  MOVF   4B,W
1171:  BSF    03,6
1172:  MOVWF  38
1173:  COMF   38,F
1174:  MOVF   38,W
1175:  MOVWF  39
1176:  BCF    03,6
1177:  BCF    0A,4
1178:  BSF    0A,3
1179:  CALL   2D4
117A:  BSF    0A,4
117B:  BCF    0A,3
....................     put_word(0);                    // Urgent ptr 
117C:  BSF    03,6
117D:  CLRF   39
117E:  CLRF   38
117F:  BCF    03,6
1180:  BCF    0A,4
1181:  BSF    0A,3
1182:  CALL   2C6
1183:  BSF    0A,4
1184:  BCF    0A,3
....................     if (tflags & TSYN)              // Adjust Tx ptr if sending MSS option 
1185:  MOVF   69,W
1186:  ANDLW  02
1187:  IORLW  00
1188:  BTFSC  03,2
1189:  GOTO   18C
....................         txin += TCPOPT_LEN; 
118A:  MOVLW  04
118B:  ADDWF  48,F
.................... } 
....................  
.................... /* Send out an IP datagram header, given data length */ 
.................... void put_ip(void) 
.................... { 
....................     static BYTE id=0; 
....................  
....................     txin = 0; 
*
0D26:  CLRF   48
....................     checkhi = checklo = 0;          // Clear checksum 
0D27:  CLRF   4B
0D28:  MOVF   4B,W
0D29:  MOVWF  4A
....................     checkflag = 0; 
0D2A:  BCF    26,2
....................     put_byte(0x45);                 // Version & hdr len */ 
0D2B:  MOVLW  45
0D2C:  BSF    03,6
0D2D:  MOVWF  39
0D2E:  BCF    03,6
0D2F:  CALL   2D4
....................     put_byte(0);                    // Service 
0D30:  BSF    03,6
0D31:  CLRF   39
0D32:  BCF    03,6
0D33:  CALL   2D4
....................     put_word(iplen); 
0D34:  MOVF   6F,W
0D35:  BSF    03,6
0D36:  MOVWF  39
0D37:  BCF    03,6
0D38:  MOVF   6E,W
0D39:  BSF    03,6
0D3A:  MOVWF  38
0D3B:  BCF    03,6
0D3C:  CALL   2C6
....................     put_byte(0);                    // Ident word 
0D3D:  BSF    03,6
0D3E:  CLRF   39
0D3F:  BCF    03,6
0D40:  CALL   2D4
....................     put_byte(++id); 
0D41:  INCF   72,F
0D42:  MOVF   72,W
0D43:  BSF    03,6
0D44:  MOVWF  39
0D45:  BCF    03,6
0D46:  CALL   2D4
....................     put_word(0);                    // Flags & fragment offset 
0D47:  BSF    03,6
0D48:  CLRF   39
0D49:  CLRF   38
0D4A:  BCF    03,6
0D4B:  CALL   2C6
....................     put_byte(100);                  // Time To Live 
0D4C:  MOVLW  64
0D4D:  BSF    03,6
0D4E:  MOVWF  39
0D4F:  BCF    03,6
0D50:  CALL   2D4
....................     put_byte(ipcol);                // Protocol 
0D51:  MOVF   4D,W
0D52:  BSF    03,6
0D53:  MOVWF  39
0D54:  BCF    03,6
0D55:  CALL   2D4
....................     check_lword(myip.l);            // Include addresses in checksum 
....................     check_lword(remip.l); 
....................     put_byte(~checkhi);             // Checksum 
*
0D7E:  MOVF   4A,W
0D7F:  BSF    03,6
0D80:  MOVWF  36
0D81:  COMF   36,F
0D82:  MOVF   36,W
0D83:  MOVWF  39
0D84:  BCF    03,6
0D85:  CALL   2D4
....................     put_byte(~checklo); 
0D86:  MOVF   4B,W
0D87:  BSF    03,6
0D88:  MOVWF  36
0D89:  COMF   36,F
0D8A:  MOVF   36,W
0D8B:  MOVWF  39
0D8C:  BCF    03,6
0D8D:  CALL   2D4
....................     put_lword(myip.l);              // Source & destination IP addrs 
....................     put_lword(remip.l); 
*
0DB6:  RETLW  00
.................... } 
....................  
.................... /* Add a 16-bit value to a longword */ 
.................... void add_lword(LWORD &lw, WORD val) 
.................... { 
....................     if ((lw.w[0] += val) < val) 
*
1BF8:  MOVF   32,W
1BF9:  BCF    03,6
1BFA:  ADDWF  5E,F
1BFB:  BSF    03,6
1BFC:  MOVF   33,W
1BFD:  BTFSC  03,0
1BFE:  ADDLW  01
1BFF:  BCF    03,6
1C00:  ADDWF  5F,F
1C01:  BSF    03,6
1C02:  MOVF   33,W
1C03:  BCF    03,6
1C04:  SUBWF  5F,W
1C05:  BTFSS  03,0
1C06:  GOTO   413
1C07:  BSF    03,6
1C08:  MOVF   33,W
1C09:  BCF    03,6
1C0A:  SUBWF  5F,W
1C0B:  BTFSS  03,2
1C0C:  GOTO   416
1C0D:  BSF    03,6
1C0E:  MOVF   32,W
1C0F:  BCF    03,6
1C10:  SUBWF  5E,W
1C11:  BTFSC  03,0
1C12:  GOTO   416
*
1C4B:  MOVF   32,W
1C4C:  BCF    03,6
1C4D:  ADDWF  5E,F
1C4E:  BSF    03,6
1C4F:  MOVF   33,W
1C50:  BTFSC  03,0
1C51:  ADDLW  01
1C52:  BCF    03,6
1C53:  ADDWF  5F,F
1C54:  BSF    03,6
1C55:  MOVF   33,W
1C56:  BCF    03,6
1C57:  SUBWF  5F,W
1C58:  BTFSS  03,0
1C59:  GOTO   466
1C5A:  BSF    03,6
1C5B:  MOVF   33,W
1C5C:  BCF    03,6
1C5D:  SUBWF  5F,W
1C5E:  BTFSS  03,2
1C5F:  GOTO   469
1C60:  BSF    03,6
1C61:  MOVF   32,W
1C62:  BCF    03,6
1C63:  SUBWF  5E,W
1C64:  BTFSC  03,0
1C65:  GOTO   469
*
1C7A:  MOVF   32,W
1C7B:  BCF    03,6
1C7C:  ADDWF  5E,F
1C7D:  BSF    03,6
1C7E:  MOVF   33,W
1C7F:  BTFSC  03,0
1C80:  ADDLW  01
1C81:  BCF    03,6
1C82:  ADDWF  5F,F
1C83:  BSF    03,6
1C84:  MOVF   33,W
1C85:  BCF    03,6
1C86:  SUBWF  5F,W
1C87:  BTFSS  03,0
1C88:  GOTO   495
1C89:  BSF    03,6
1C8A:  MOVF   33,W
1C8B:  BCF    03,6
1C8C:  SUBWF  5F,W
1C8D:  BTFSS  03,2
1C8E:  GOTO   498
1C8F:  BSF    03,6
1C90:  MOVF   32,W
1C91:  BCF    03,6
1C92:  SUBWF  5E,W
1C93:  BTFSC  03,0
1C94:  GOTO   498
....................         lw.w[1]++; 
*
1C13:  INCF   60,F
1C14:  BTFSC  03,2
1C15:  INCF   61,F
*
1C66:  INCF   60,F
1C67:  BTFSC  03,2
1C68:  INCF   61,F
*
1C95:  INCF   60,F
1C96:  BTFSC  03,2
1C97:  INCF   61,F
.................... } 
....................  
.................... /* EOF */ 
.................... 
.................... #include "\chipweb\pcm\webrom.h" 
....................  /* Definitions for Web ROM filesystem */ 
....................  
.................... /* The filesystem is in 1 or more ROMs. At the start of the first ROM is a 
.................... ** directory of 1 or more filename blocks, each of which have pointers to 
.................... ** data blocks. The end of the directory is marked by a dummy length of FFFFh 
.................... ** 
.................... ** All the files include the appropriate HTTP headers. 
.................... */ 
....................  
.................... #define ROM_FNAMELEN    12  /* Maximum filename size */ 
....................  
.................... typedef struct          /* Filename block structure */ 
.................... { 
....................     WORD len;               /* Length of file in bytes */ 
....................     WORD start;             /* Start address of file data in ROM */ 
....................     WORD check;             /* TCP checksum of file */ 
....................     BYTE flags;             /* Embedded Gateway Interface (EGI) flags */ 
....................     char name[ROM_FNAMELEN];/* Lower-case filename with extension */ 
.................... } ROM_FNAME; 
....................  
.................... /* Embedded Gateway Interface (EGI) flag values */ 
.................... #define EGI_ATVARS      0x01    /* '@' variable substitution scheme */ 
.................... #define EGI_HASHVARS    0x02    /* '#' and '|' boolean variables */ 
....................  
.................... /* EOF */ 
....................  
.................... 
.................... #include "\chipweb\pcm\p16_http.h" 
....................  /* HTTP support for CHIPWEB on PICDEM.net 
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
.................... /* 
.................... ** v0.01 10/1/01 JPB 
.................... */ 
....................  
.................... #define HTTP_FAIL       "HTTP/ 200 OK\r\n\r\nNo Web pages!\r\n" 
....................  
.................... #define MAXFILES    100     // Limit on ROM file count (to stop runaway) 
.................... typedef union               // ROM file directory entry format 
.................... { 
....................     ROM_FNAME f;                // Union of filename.. 
....................     BYTE b[sizeof(ROM_FNAME)];  // ..with byte values for i2c transfer 
.................... } ROM_DIR; 
....................  
.................... ROM_DIR romdir;             // Storage for one directory entry 
.................... int fileidx;                // Index of current file (1=first, 0=error) 
....................  
.................... void check_formargs(void); 
.................... BOOL find_file(void); 
.................... BOOL open_file(void); 
.................... void close_file(void); 
.................... BOOL tx_file_byte(void); 
.................... void putnic_volts(WORD val); 
....................  
.................... /* Receive an incoming HTTP request ('method'), return 0 if invalid */ 
.................... #separate 
.................... BOOL http_recv(void) 
.................... { 
....................     int len, i; 
....................     BOOL ret=0; 
....................     char c; 
*
1208:  BSF    03,6
1209:  BCF    32,0
....................     WORD blen; 
....................  
....................     tpxdlen = 0;                    // Check for 'GET' 
120A:  BCF    03,6
120B:  CLRF   29
120C:  CLRF   28
....................     DEBUG_PUTC('h'); 
....................     if (match_byte('G') && match_byte('E') && match_byte('T')) 
120D:  MOVLW  47
120E:  BSF    03,6
120F:  MOVWF  36
1210:  BCF    03,6
1211:  BCF    0A,4
1212:  BSF    0A,3
1213:  CALL   291
1214:  BSF    0A,4
1215:  BCF    0A,3
1216:  MOVF   78,F
1217:  BTFSC  03,2
1218:  GOTO   4A2
1219:  MOVLW  45
121A:  BSF    03,6
121B:  MOVWF  36
121C:  BCF    03,6
121D:  BCF    0A,4
121E:  BSF    0A,3
121F:  CALL   291
1220:  BSF    0A,4
1221:  BCF    0A,3
1222:  MOVF   78,F
1223:  BTFSC  03,2
1224:  GOTO   4A2
1225:  MOVLW  54
1226:  BSF    03,6
1227:  MOVWF  36
1228:  BCF    03,6
1229:  BCF    0A,4
122A:  BSF    0A,3
122B:  CALL   291
122C:  BSF    0A,4
122D:  BCF    0A,3
122E:  MOVF   78,F
122F:  BTFSC  03,2
1230:  GOTO   4A2
....................     { 
....................         ret = 1; 
1231:  BSF    03,6
1232:  BSF    32,0
....................         match_byte(' '); 
1233:  MOVLW  20
1234:  MOVWF  36
1235:  BCF    03,6
1236:  BCF    0A,4
1237:  BSF    0A,3
1238:  CALL   291
1239:  BSF    0A,4
123A:  BCF    0A,3
....................         match_byte('/');            // Start of filename 
123B:  MOVLW  2F
123C:  BSF    03,6
123D:  MOVWF  36
123E:  BCF    03,6
123F:  BCF    0A,4
1240:  BSF    0A,3
1241:  CALL   291
1242:  BSF    0A,4
1243:  BCF    0A,3
....................         DEBUG_PUTC(' '); 
....................         memset(romdir.f.name, 0, ROM_FNAMELEN); 
1244:  MOVLW  0C
1245:  MOVWF  78
1246:  MOVLW  17
1247:  MOVWF  04
1248:  BSF    03,7
1249:  CLRF   00
124A:  INCF   04,F
124B:  DECFSZ 78,F
124C:  GOTO   249
....................         for (i=0; i<ROM_FNAMELEN && get_byte(c) && c>' ' && c!='?'; i++) 
124D:  BSF    03,6
124E:  CLRF   31
124F:  BCF    03,6
1250:  MOVLW  0C
1251:  BSF    03,6
1252:  SUBWF  31,W
1253:  BTFSS  03,0
1254:  GOTO   257
1255:  BCF    03,6
1256:  GOTO   299
1257:  BCF    03,6
*
126D:  MOVF   78,F
126E:  BTFSC  03,2
126F:  GOTO   299
1270:  MOVLW  21
1271:  BSF    03,6
1272:  SUBWF  33,W
1273:  BTFSC  03,0
1274:  GOTO   277
1275:  BCF    03,6
1276:  GOTO   299
1277:  BCF    03,6
1278:  MOVLW  3F
1279:  BSF    03,6
127A:  SUBWF  33,W
127B:  BTFSS  03,2
127C:  GOTO   27F
127D:  BCF    03,6
127E:  GOTO   299
127F:  BCF    03,6
....................         {                           // Name terminated by space or '?' 
....................             DEBUG_PUTC(c); 
....................             romdir.f.name[i] = c; 
1280:  MOVLW  07
1281:  BSF    03,6
1282:  ADDWF  31,W
1283:  BCF    03,6
1284:  MOVWF  77
1285:  MOVLW  10
1286:  ADDWF  77,W
1287:  MOVWF  79
1288:  MOVLW  01
1289:  MOVWF  7A
128A:  MOVF   79,W
128B:  BTFSC  03,0
128C:  INCF   7A,F
128D:  MOVWF  04
128E:  BCF    03,7
128F:  BTFSC  7A,0
1290:  BSF    03,7
1291:  BSF    03,6
1292:  MOVF   33,W
1293:  MOVWF  00
1294:  BCF    03,6
....................         }                           // If file found in ROM 
1295:  BSF    03,6
1296:  INCF   31,F
1297:  BCF    03,6
1298:  GOTO   250
....................         if (find_file()) 
1299:  BCF    0A,4
129A:  BSF    0A,3
129B:  CALL   628
129C:  BSF    0A,4
129D:  BCF    0A,3
129E:  MOVF   78,F
129F:  BTFSC  03,2
12A0:  GOTO   2D8
....................         {                           // ..check for form arguments 
....................             DEBUG_PUTC('>'); 
....................             check_formargs(); 
....................         } 
....................         else                        // File not found, get index.htm 
*
12D7:  GOTO   2E0
....................         { 
....................             DEBUG_PUTC('?'); 
....................             romdir.f.name[0] = 0; 
12D8:  BSF    03,6
12D9:  CLRF   17
....................             find_file(); 
12DA:  BCF    03,6
12DB:  BCF    0A,4
12DC:  BSF    0A,3
12DD:  CALL   628
12DE:  BSF    0A,4
12DF:  BCF    0A,3
....................         } 
....................         checkhi = checklo = 0; 
12E0:  CLRF   4B
12E1:  MOVF   4B,W
12E2:  MOVWF  4A
....................         checkflag = 0; 
12E3:  BCF    26,2
....................         txin = IPHDR_LEN + TCPHDR_LEN;   
12E4:  MOVLW  28
12E5:  MOVWF  48
....................         if (!fileidx)               // No files at all in ROM - disaster! 
12E6:  MOVF   73,F
12E7:  BTFSS  03,2
12E8:  GOTO   316
....................         { 
....................             setnic_addr((TXSTART<<8)+sizeof(ETHERHEADER)+IPHDR_LEN+TCPHDR_LEN); 
12E9:  MOVLW  40
12EA:  BSF    03,6
12EB:  MOVWF  3D
12EC:  MOVLW  36
12ED:  MOVWF  3C
12EE:  BCF    03,6
12EF:  BCF    0A,4
12F0:  BSF    0A,3
12F1:  CALL   063
12F2:  BSF    0A,4
12F3:  BCF    0A,3
....................             printf(putnic_checkbyte, HTTP_FAIL);     
*
0065:  BCF    0A,0
0066:  BCF    0A,1
0067:  BCF    0A,2
0068:  ADDWF  02,F
0069:  RETLW  48
006A:  RETLW  54
006B:  RETLW  54
006C:  RETLW  50
006D:  RETLW  2F
006E:  RETLW  20
006F:  RETLW  32
0070:  RETLW  30
0071:  RETLW  30
0072:  RETLW  20
0073:  RETLW  4F
0074:  RETLW  4B
0075:  RETLW  0D
0076:  RETLW  0A
0077:  RETLW  0D
0078:  RETLW  0A
0079:  RETLW  4E
007A:  RETLW  6F
007B:  RETLW  20
007C:  RETLW  57
007D:  RETLW  65
007E:  RETLW  62
007F:  RETLW  20
0080:  RETLW  70
0081:  RETLW  61
0082:  RETLW  67
0083:  RETLW  65
0084:  RETLW  73
0085:  RETLW  21
0086:  RETLW  0D
0087:  RETLW  0A
0088:  RETLW  00
*
12F4:  BSF    03,6
12F5:  CLRF   36
12F6:  BCF    03,6
12F7:  BSF    03,6
12F8:  MOVF   36,W
12F9:  BCF    03,6
12FA:  BCF    0A,4
12FB:  CALL   065
12FC:  BSF    0A,4
12FD:  BSF    03,6
12FE:  INCF   36,F
12FF:  MOVWF  3D
1300:  BCF    03,6
1301:  BCF    0A,4
1302:  BSF    0A,3
1303:  CALL   735
1304:  BSF    0A,4
1305:  BCF    0A,3
1306:  MOVLW  1F
1307:  BSF    03,6
1308:  SUBWF  36,W
1309:  BTFSC  03,2
130A:  GOTO   30D
130B:  BCF    03,6
130C:  GOTO   2F7
....................             tflags = TFIN+TACK;     
130D:  MOVLW  11
130E:  BCF    03,6
130F:  MOVWF  69
....................             d_checkhi = checkhi; 
1310:  MOVF   4A,W
1311:  MOVWF  70
....................             d_checklo = checklo; 
1312:  MOVF   4B,W
1313:  MOVWF  71
....................             tcp_xmit(); 
1314:  CALL   000
....................         } 
....................         else                        // File found OK 
1315:  GOTO   4A2
....................         { 
....................             open_file();                // Start i2c transfer 
....................             setnic_addr((TXSTART<<8)+sizeof(ETHERHEADER)+IPHDR_LEN+TCPHDR_LEN); 
*
1360:  MOVLW  40
1361:  BSF    03,6
1362:  MOVWF  3D
1363:  MOVLW  36
1364:  MOVWF  3C
1365:  BCF    03,6
1366:  BCF    0A,4
1367:  BSF    0A,3
1368:  CALL   063
1369:  BSF    0A,4
136A:  BCF    0A,3
....................             while (tx_file_byte())      // Copy bytes from ROM to NIC 
*
1483:  MOVF   78,F
1484:  BTFSS  03,2
1485:  GOTO   36B
....................                 ; 
....................             close_file(); 
....................             tflags = TFIN+TPUSH+TACK;   // Close connection when sent 
*
149B:  MOVLW  19
149C:  MOVWF  69
....................             d_checkhi = checkhi;        // Save checksum 
149D:  MOVF   4A,W
149E:  MOVWF  70
....................             d_checklo = checklo; 
149F:  MOVF   4B,W
14A0:  MOVWF  71
....................             tcp_xmit();                 // Do header, transmit segment 
14A1:  CALL   000
....................         } 
....................     } 
....................     return(ret); 
14A2:  MOVLW  00
14A3:  BSF    03,6
14A4:  BTFSC  32,0
14A5:  MOVLW  01
14A6:  BCF    03,6
14A7:  MOVWF  78
14A8:  BSF    0A,3
14A9:  BSF    0A,4
14AA:  GOTO   4A9
.................... } 
....................  
.................... /* Check for arguments in HTTP request string 
.................... ** Simple version: just check last 2 digits of filename, copy to 2 LEDs */ 
.................... void check_formargs(void) 
.................... { 
....................     if (romdir.f.name[6]=='0' || romdir.f.name[6]=='1') 
*
12A1:  MOVLW  30
12A2:  BSF    03,6
12A3:  SUBWF  1D,W
12A4:  BTFSS  03,2
12A5:  GOTO   2A8
12A6:  BCF    03,6
12A7:  GOTO   2B1
12A8:  BCF    03,6
12A9:  MOVLW  31
12AA:  BSF    03,6
12AB:  SUBWF  1D,W
12AC:  BTFSC  03,2
12AD:  GOTO   2B0
12AE:  BCF    03,6
12AF:  GOTO   2BC
12B0:  BCF    03,6
....................         USERLED1 = (romdir.f.name[6] == '0'); 
12B1:  MOVLW  30
12B2:  BSF    03,6
12B3:  SUBWF  1D,W
12B4:  BTFSS  03,2
12B5:  GOTO   2B8
12B6:  BCF    03,6
12B7:  GOTO   2BB
12B8:  BCF    03,6
12B9:  BCF    05,2
12BA:  GOTO   2BC
12BB:  BSF    05,2
....................     if (romdir.f.name[7]=='0' || romdir.f.name[7]=='1') 
12BC:  MOVLW  30
12BD:  BSF    03,6
12BE:  SUBWF  1E,W
12BF:  BTFSS  03,2
12C0:  GOTO   2C3
12C1:  BCF    03,6
12C2:  GOTO   2CC
12C3:  BCF    03,6
12C4:  MOVLW  31
12C5:  BSF    03,6
12C6:  SUBWF  1E,W
12C7:  BTFSC  03,2
12C8:  GOTO   2CB
12C9:  BCF    03,6
12CA:  GOTO   2D7
12CB:  BCF    03,6
....................         USERLED2 = (romdir.f.name[7] == '0'); 
12CC:  MOVLW  30
12CD:  BSF    03,6
12CE:  SUBWF  1E,W
12CF:  BTFSS  03,2
12D0:  GOTO   2D3
12D1:  BCF    03,6
12D2:  GOTO   2D6
12D3:  BCF    03,6
12D4:  BCF    05,3
12D5:  GOTO   2D7
12D6:  BSF    05,3
.................... } 
....................  
.................... /* Find a filename in ROM filesystem. Return false if not found 
.................... ** Sets fileidx to 0 if ROM error, 1 if file is first in ROM, 2 if 2nd.. 
.................... ** and leaves directory info in 'romdir' 
.................... ** If the first byte of name is zero, match first directory entry */ 
.................... BOOL find_file(void) 
.................... { 
....................     BOOL mismatch=1, end=0; 
....................     int i; 
....................     BYTE b; 
*
0E28:  BSF    03,6
0E29:  BSF    36,0
0E2A:  BCF    36,1
....................     char temps[ROM_FNAMELEN]; 
....................  
....................     fileidx = 0;                        // Set ROM address pointer to 0 
0E2B:  BCF    03,6
0E2C:  CLRF   73
....................     i2c_start(); 
0E2D:  BSF    03,5
0E2E:  BSF    07,4
0E2F:  CLRWDT
0E30:  BSF    07,3
0E31:  CLRWDT
0E32:  BCF    03,5
0E33:  BCF    07,4
0E34:  BSF    03,5
0E35:  BCF    07,4
0E36:  CLRWDT
0E37:  BCF    03,5
0E38:  BCF    07,3
0E39:  BSF    03,5
0E3A:  BCF    07,3
....................     i2c_write(EEROM_ADDR); 
0E3B:  MOVLW  A0
0E3C:  BCF    03,5
0E3D:  BSF    03,6
0E3E:  MOVWF  45
0E3F:  BCF    03,6
0E40:  BCF    0A,3
0E41:  CALL   3B0
0E42:  BSF    0A,3
....................     i2c_write(0); 
0E43:  BSF    03,6
0E44:  CLRF   45
0E45:  BCF    03,6
0E46:  BCF    0A,3
0E47:  CALL   3B0
0E48:  BSF    0A,3
....................     i2c_write(0); 
0E49:  BSF    03,6
0E4A:  CLRF   45
0E4B:  BCF    03,6
0E4C:  BCF    0A,3
0E4D:  CALL   3B0
0E4E:  BSF    0A,3
....................     i2c_stop(); 
0E4F:  BSF    03,5
0E50:  BCF    07,4
0E51:  NOP
0E52:  BSF    07,3
0E53:  BCF    03,5
0E54:  BTFSS  07,3
0E55:  GOTO   654
0E56:  CLRWDT
0E57:  NOP
0E58:  NOP
0E59:  NOP
0E5A:  BSF    03,5
0E5B:  BSF    07,4
0E5C:  CLRWDT
0E5D:  BCF    03,5
....................     do 
....................     { 
....................         i2c_start();                    // Read next directory entry 
0E5E:  BSF    03,5
0E5F:  BSF    07,4
0E60:  CLRWDT
0E61:  BSF    07,3
0E62:  CLRWDT
0E63:  BCF    03,5
0E64:  BCF    07,4
0E65:  BSF    03,5
0E66:  BCF    07,4
0E67:  CLRWDT
0E68:  BCF    03,5
0E69:  BCF    07,3
0E6A:  BSF    03,5
0E6B:  BCF    07,3
....................         i2c_write(EEROM_ADDR | 1); 
0E6C:  MOVLW  A1
0E6D:  BCF    03,5
0E6E:  BSF    03,6
0E6F:  MOVWF  45
0E70:  BCF    03,6
0E71:  BCF    0A,3
0E72:  CALL   3B0
0E73:  BSF    0A,3
....................         if ((romdir.b[0] = i2c_read(1)) == 0xff) 
0E74:  MOVLW  01
0E75:  MOVWF  77
0E76:  CALL   5E8
0E77:  MOVF   78,W
0E78:  BSF    03,6
0E79:  MOVWF  10
0E7A:  INCF   10,W
0E7B:  BTFSC  03,2
0E7C:  GOTO   67F
0E7D:  BCF    03,6
0E7E:  GOTO   686
0E7F:  BCF    03,6
....................         {                               // Abandon if no entry 
....................             end = 1; 
0E80:  BSF    03,6
0E81:  BSF    36,1
....................             i2c_read(0); 
0E82:  BCF    03,6
0E83:  CLRF   77
0E84:  CALL   5E8
....................         } 
....................         else 
0E85:  GOTO   702
....................         {                               // Get file len, ptr, csum and flags 
....................             for (i=1; i<7; i++) 
0E86:  MOVLW  01
0E87:  BSF    03,6
0E88:  MOVWF  37
0E89:  BCF    03,6
0E8A:  MOVLW  07
0E8B:  BSF    03,6
0E8C:  SUBWF  37,W
0E8D:  BTFSS  03,0
0E8E:  GOTO   691
0E8F:  BCF    03,6
0E90:  GOTO   6A9
0E91:  BCF    03,6
....................                 romdir.b[i] = i2c_read(1); 
0E92:  MOVLW  10
0E93:  BSF    03,6
0E94:  ADDWF  37,W
0E95:  BCF    03,6
0E96:  MOVWF  79
0E97:  MOVLW  01
0E98:  MOVWF  7A
0E99:  MOVF   79,W
0E9A:  BTFSC  03,0
0E9B:  INCF   7A,F
0E9C:  MOVWF  04
0E9D:  BCF    03,7
0E9E:  BTFSC  7A,0
0E9F:  BSF    03,7
0EA0:  MOVLW  01
0EA1:  MOVWF  77
0EA2:  CALL   5E8
0EA3:  MOVF   78,W
0EA4:  MOVWF  00
0EA5:  BSF    03,6
0EA6:  INCF   37,F
0EA7:  BCF    03,6
0EA8:  GOTO   68A
....................             mismatch = 0;               // Try matching name 
0EA9:  BSF    03,6
0EAA:  BCF    36,0
....................             for (i=0; i<ROM_FNAMELEN; i++) 
0EAB:  CLRF   37
0EAC:  BCF    03,6
0EAD:  MOVLW  0C
0EAE:  BSF    03,6
0EAF:  SUBWF  37,W
0EB0:  BTFSS  03,0
0EB1:  GOTO   6B4
0EB2:  BCF    03,6
0EB3:  GOTO   6F8
0EB4:  BCF    03,6
....................             { 
....................                 temps[i] = b = i2c_read(i<ROM_FNAMELEN-1); 
0EB5:  MOVLW  39
0EB6:  BSF    03,6
0EB7:  ADDWF  37,W
0EB8:  BCF    03,6
0EB9:  MOVWF  79
0EBA:  MOVLW  01
0EBB:  MOVWF  7A
0EBC:  MOVF   79,W
0EBD:  BTFSC  03,0
0EBE:  INCF   7A,F
0EBF:  MOVWF  04
0EC0:  BCF    03,7
0EC1:  BTFSC  7A,0
0EC2:  BSF    03,7
0EC3:  MOVLW  0B
0EC4:  BSF    03,6
0EC5:  SUBWF  37,W
0EC6:  BTFSC  03,0
0EC7:  GOTO   6CA
0EC8:  BCF    03,6
0EC9:  GOTO   6CD
0ECA:  BCF    03,6
0ECB:  MOVLW  00
0ECC:  GOTO   6CE
0ECD:  MOVLW  01
0ECE:  BSF    03,6
0ECF:  MOVWF  47
0ED0:  MOVF   47,W
0ED1:  BCF    03,6
0ED2:  MOVWF  77
0ED3:  CALL   5E8
0ED4:  MOVF   78,W
0ED5:  BSF    03,6
0ED6:  MOVWF  38
0ED7:  MOVF   38,W
0ED8:  MOVWF  00
....................                 if (b != romdir.f.name[i]) 
0ED9:  MOVLW  07
0EDA:  ADDWF  37,W
0EDB:  BCF    03,6
0EDC:  MOVWF  77
0EDD:  MOVLW  10
0EDE:  ADDWF  77,W
0EDF:  MOVWF  79
0EE0:  MOVLW  01
0EE1:  MOVWF  7A
0EE2:  MOVF   79,W
0EE3:  BTFSC  03,0
0EE4:  INCF   7A,F
0EE5:  MOVWF  04
0EE6:  BCF    03,7
0EE7:  BTFSC  7A,0
0EE8:  BSF    03,7
0EE9:  MOVF   00,W
0EEA:  BSF    03,6
0EEB:  SUBWF  38,W
0EEC:  BTFSS  03,2
0EED:  GOTO   6F0
0EEE:  BCF    03,6
0EEF:  GOTO   6F4
0EF0:  BCF    03,6
....................                     mismatch = 1; 
0EF1:  BSF    03,6
0EF2:  BSF    36,0
0EF3:  BCF    03,6
....................             } 
0EF4:  BSF    03,6
0EF5:  INCF   37,F
0EF6:  BCF    03,6
0EF7:  GOTO   6AD
....................             if (!romdir.f.name[0])      // If null name, match anything 
0EF8:  BSF    03,6
0EF9:  MOVF   17,F
0EFA:  BTFSC  03,2
0EFB:  GOTO   6FE
0EFC:  BCF    03,6
0EFD:  GOTO   702
0EFE:  BCF    03,6
....................                 mismatch = 0; 
0EFF:  BSF    03,6
0F00:  BCF    36,0
0F01:  BCF    03,6
....................         } 
....................         i2c_stop();                     // Loop until matched 
0F02:  BSF    03,5
0F03:  BCF    07,4
0F04:  NOP
0F05:  BSF    07,3
0F06:  BCF    03,5
0F07:  BTFSS  07,3
0F08:  GOTO   707
0F09:  CLRWDT
0F0A:  NOP
0F0B:  NOP
0F0C:  NOP
0F0D:  BSF    03,5
0F0E:  BSF    07,4
0F0F:  CLRWDT
0F10:  BCF    03,5
....................     } while (!end && fileidx++<MAXFILES && mismatch); 
0F11:  BSF    03,6
0F12:  BTFSS  36,1
0F13:  GOTO   716
0F14:  BCF    03,6
0F15:  GOTO   724
0F16:  BCF    03,6
0F17:  MOVF   73,W
0F18:  INCF   73,F
0F19:  MOVWF  77
0F1A:  MOVLW  64
0F1B:  SUBWF  77,W
0F1C:  BTFSC  03,0
0F1D:  GOTO   724
0F1E:  BSF    03,6
0F1F:  BTFSS  36,0
0F20:  GOTO   723
0F21:  BCF    03,6
0F22:  GOTO   65E
0F23:  BCF    03,6
....................     if (mismatch) 
0F24:  BSF    03,6
0F25:  BTFSC  36,0
0F26:  GOTO   729
0F27:  BCF    03,6
0F28:  GOTO   72E
0F29:  BCF    03,6
....................         romdir.f.len = 0; 
0F2A:  BSF    03,6
0F2B:  CLRF   11
0F2C:  CLRF   10
0F2D:  BCF    03,6
....................     return(!mismatch); 
0F2E:  MOVLW  00
0F2F:  BSF    03,6
0F30:  BTFSS  36,0
0F31:  MOVLW  01
0F32:  BCF    03,6
0F33:  MOVWF  78
0F34:  RETLW  00
.................... } 
....................  
.................... /* Open the previously-found file for transmission */ 
.................... BOOL open_file(void) 
.................... {     
....................     i2c_start(); 
*
1316:  BSF    03,5
1317:  BSF    07,4
1318:  CLRWDT
1319:  BSF    07,3
131A:  CLRWDT
131B:  BCF    03,5
131C:  BCF    07,4
131D:  BSF    03,5
131E:  BCF    07,4
131F:  CLRWDT
1320:  BCF    03,5
1321:  BCF    07,3
1322:  BSF    03,5
1323:  BCF    07,3
....................     i2c_write(EEROM_ADDR);              // Write start pointer to eerom 
1324:  MOVLW  A0
1325:  BCF    03,5
1326:  BSF    03,6
1327:  MOVWF  45
1328:  BCF    03,6
1329:  BCF    0A,4
132A:  CALL   3B0
132B:  BSF    0A,4
....................     i2c_write(romdir.f.start >> 8); 
132C:  BSF    03,6
132D:  MOVF   13,W
132E:  MOVWF  36
132F:  CLRF   37
1330:  MOVF   36,W
1331:  MOVWF  45
1332:  BCF    03,6
1333:  BCF    0A,4
1334:  CALL   3B0
1335:  BSF    0A,4
....................     i2c_write(romdir.f.start); 
1336:  BSF    03,6
1337:  MOVF   12,W
1338:  MOVWF  45
1339:  BCF    03,6
133A:  BCF    0A,4
133B:  CALL   3B0
133C:  BSF    0A,4
....................     i2c_stop(); 
133D:  BSF    03,5
133E:  BCF    07,4
133F:  NOP
1340:  BSF    07,3
1341:  BCF    03,5
1342:  BTFSS  07,3
1343:  GOTO   342
1344:  CLRWDT
1345:  NOP
1346:  NOP
1347:  NOP
1348:  BSF    03,5
1349:  BSF    07,4
134A:  CLRWDT
....................     i2c_start(); 
134B:  BSF    07,4
134C:  CLRWDT
134D:  BSF    07,3
134E:  CLRWDT
134F:  BCF    03,5
1350:  BCF    07,4
1351:  BSF    03,5
1352:  BCF    07,4
1353:  CLRWDT
1354:  BCF    03,5
1355:  BCF    07,3
1356:  BSF    03,5
1357:  BCF    07,3
....................     i2c_write(EEROM_ADDR | 1);          // Restart ROM access as read cycle 
1358:  MOVLW  A1
1359:  BCF    03,5
135A:  BSF    03,6
135B:  MOVWF  45
135C:  BCF    03,6
135D:  BCF    0A,4
135E:  CALL   3B0
135F:  BSF    0A,4
.................... } 
....................  
.................... /* Close the previously-opened file */ 
.................... void close_file(void) 
.................... { 
....................     i2c_read(0);                        // Dummy read cycle without ACK 
*
1486:  CLRF   77
1487:  BCF    0A,4
1488:  BSF    0A,3
1489:  CALL   5E8
148A:  BSF    0A,4
148B:  BCF    0A,3
....................     i2c_stop(); 
148C:  BSF    03,5
148D:  BCF    07,4
148E:  NOP
148F:  BSF    07,3
1490:  BCF    03,5
1491:  BTFSS  07,3
1492:  GOTO   491
1493:  CLRWDT
1494:  NOP
1495:  NOP
1496:  NOP
1497:  BSF    03,5
1498:  BSF    07,4
1499:  CLRWDT
149A:  BCF    03,5
.................... } 
....................  
.................... /* Transmit a byte from the current i2c file to the NIC 
.................... ** Return 0 when complete file is sent 
.................... ** If file has EGI flag set, perform run-time variable substitution */ 
.................... BOOL tx_file_byte(void) 
.................... { 
....................     int ret=0, idx; 
*
136B:  BSF    03,6
136C:  CLRF   36
....................     BYTE b; 
....................  
....................     if (romdir.f.len)                   // Check if any bytes left to send 
136D:  MOVF   10,W
136E:  IORWF  11,W
136F:  BTFSS  03,2
1370:  GOTO   373
1371:  BCF    03,6
1372:  GOTO   47F
1373:  BCF    03,6
....................     { 
....................         b = i2c_read(1);                // Get next byte from ROM 
1374:  MOVLW  01
1375:  MOVWF  77
1376:  BCF    0A,4
1377:  BSF    0A,3
1378:  CALL   5E8
1379:  BSF    0A,4
137A:  BCF    0A,3
137B:  MOVF   78,W
137C:  BSF    03,6
137D:  MOVWF  38
....................         if ((romdir.f.flags&EGI_ATVARS) && b=='@') 
137E:  MOVF   16,W
137F:  ANDLW  01
1380:  IORLW  00
1381:  BTFSS  03,2
1382:  GOTO   385
1383:  BCF    03,6
1384:  GOTO   46E
1385:  BCF    03,6
1386:  MOVLW  40
1387:  BSF    03,6
1388:  SUBWF  38,W
1389:  BTFSC  03,2
138A:  GOTO   38D
138B:  BCF    03,6
138C:  GOTO   46E
138D:  BCF    03,6
....................         {                               // If '@' and EGI var substitution.. 
....................             b = i2c_read(1);            // ..get 2nd byte 
138E:  MOVLW  01
138F:  MOVWF  77
1390:  BCF    0A,4
1391:  BSF    0A,3
1392:  CALL   5E8
1393:  BSF    0A,4
1394:  BCF    0A,3
1395:  MOVF   78,W
1396:  BSF    03,6
1397:  MOVWF  38
....................             romdir.f.len--; 
1398:  MOVF   10,W
1399:  BTFSC  03,2
139A:  DECF   11,F
139B:  DECF   10,F
....................             idx = b - 0x30; 
139C:  MOVF   38,W
139D:  MOVWF  37
139E:  MOVLW  30
139F:  SUBWF  37,F
....................             if (idx == 1)               // Scaled ADC value for slider 1 
13A0:  MOVLW  01
13A1:  SUBWF  37,W
13A2:  BTFSC  03,2
13A3:  GOTO   3A6
13A4:  BCF    03,6
13A5:  GOTO   3C7
13A6:  BCF    03,6
....................                 printf(putnic_checkbyte, "%u", (BYTE)(adc1/11)+6); 
*
0F43:  CLRF   78
0F44:  CLRF   79
0F45:  CLRF   77
0F46:  CLRF   7A
0F47:  BSF    03,6
0F48:  MOVF   3F,W
0F49:  BTFSC  03,2
0F4A:  GOTO   74D
0F4B:  BCF    03,6
0F4C:  GOTO   753
0F4D:  MOVF   3E,W
0F4E:  BTFSS  03,2
0F4F:  GOTO   752
0F50:  BCF    03,6
0F51:  GOTO   77E
0F52:  BCF    03,6
0F53:  MOVLW  10
0F54:  BSF    03,6
0F55:  MOVWF  40
0F56:  BCF    03,6
0F57:  BCF    03,0
0F58:  BSF    03,6
0F59:  RLF    3C,F
0F5A:  RLF    3D,F
0F5B:  BCF    03,6
0F5C:  RLF    77,F
0F5D:  RLF    7A,F
0F5E:  BSF    03,6
0F5F:  MOVF   3F,W
0F60:  BCF    03,6
0F61:  SUBWF  7A,W
0F62:  BTFSS  03,2
0F63:  GOTO   768
0F64:  BSF    03,6
0F65:  MOVF   3E,W
0F66:  BCF    03,6
0F67:  SUBWF  77,W
0F68:  BTFSS  03,0
0F69:  GOTO   775
0F6A:  BSF    03,6
0F6B:  MOVF   3E,W
0F6C:  BCF    03,6
0F6D:  SUBWF  77,F
0F6E:  BTFSS  03,0
0F6F:  DECF   7A,F
0F70:  BSF    03,6
0F71:  MOVF   3F,W
0F72:  BCF    03,6
0F73:  SUBWF  7A,F
0F74:  BSF    03,0
0F75:  RLF    78,F
0F76:  RLF    79,F
0F77:  BSF    03,6
0F78:  DECFSZ 40,F
0F79:  GOTO   77B
0F7A:  GOTO   77D
0F7B:  BCF    03,6
0F7C:  GOTO   757
0F7D:  BCF    03,6
0F7E:  NOP
0F7F:  RETLW  00
0F80:  BSF    03,6
0F81:  BTFSS  3B,0
0F82:  GOTO   785
0F83:  BCF    03,6
0F84:  GOTO   7AC
0F85:  BTFSS  3B,1
0F86:  GOTO   789
0F87:  BCF    03,6
0F88:  GOTO   7CB
0F89:  MOVF   3A,W
0F8A:  MOVWF  3C
0F8B:  MOVLW  64
0F8C:  MOVWF  3D
0F8D:  BCF    03,6
0F8E:  BCF    0A,3
0F8F:  CALL   7D6
0F90:  BSF    0A,3
0F91:  MOVF   77,W
0F92:  BSF    03,6
0F93:  MOVWF  3A
0F94:  BCF    03,6
0F95:  MOVF   78,W
0F96:  MOVLW  30
0F97:  BTFSS  03,2
0F98:  GOTO   7A2
0F99:  BSF    03,6
0F9A:  BTFSS  3B,2
0F9B:  GOTO   79E
0F9C:  BCF    03,6
0F9D:  GOTO   7AC
0F9E:  BTFSC  3B,3
0F9F:  MOVLW  20
0FA0:  BCF    03,6
0FA1:  GOTO   7A6
0FA2:  BSF    03,6
0FA3:  BCF    3B,2
0FA4:  BCF    3B,3
0FA5:  BCF    03,6
0FA6:  ADDWF  78,F
0FA7:  MOVF   78,W
0FA8:  BSF    03,6
0FA9:  MOVWF  3D
0FAA:  BCF    03,6
0FAB:  CALL   735
0FAC:  BSF    03,6
0FAD:  MOVF   3A,W
0FAE:  MOVWF  3C
0FAF:  MOVLW  0A
0FB0:  MOVWF  3D
0FB1:  BCF    03,6
0FB2:  BCF    0A,3
0FB3:  CALL   7D6
0FB4:  BSF    0A,3
0FB5:  MOVF   77,W
0FB6:  BSF    03,6
0FB7:  MOVWF  3A
0FB8:  BCF    03,6
0FB9:  MOVF   78,W
0FBA:  MOVLW  30
0FBB:  BTFSS  03,2
0FBC:  GOTO   7C5
0FBD:  BSF    03,6
0FBE:  BTFSS  3B,2
0FBF:  GOTO   7C2
0FC0:  BCF    03,6
0FC1:  GOTO   7CB
0FC2:  BTFSC  3B,3
0FC3:  MOVLW  20
0FC4:  BCF    03,6
0FC5:  ADDWF  78,F
0FC6:  MOVF   78,W
0FC7:  BSF    03,6
0FC8:  MOVWF  3D
0FC9:  BCF    03,6
0FCA:  CALL   735
0FCB:  MOVLW  30
0FCC:  BSF    03,6
0FCD:  ADDWF  3A,F
0FCE:  MOVF   3A,W
0FCF:  MOVWF  3D
0FD0:  BCF    03,6
0FD1:  CALL   735
0FD2:  RETLW  00
*
13A7:  MOVF   22,W
13A8:  BSF    03,6
13A9:  MOVWF  3D
13AA:  BCF    03,6
13AB:  MOVF   21,W
13AC:  BSF    03,6
13AD:  MOVWF  3C
13AE:  MOVLW  00
13AF:  MOVWF  3F
13B0:  MOVLW  0B
13B1:  MOVWF  3E
13B2:  BCF    03,6
13B3:  BCF    0A,4
13B4:  BSF    0A,3
13B5:  CALL   743
13B6:  BSF    0A,4
13B7:  BCF    0A,3
13B8:  MOVLW  06
13B9:  ADDWF  78,W
13BA:  BSF    03,6
13BB:  MOVWF  39
13BC:  MOVF   39,W
13BD:  MOVWF  3A
13BE:  MOVLW  0C
13BF:  MOVWF  3B
13C0:  BCF    03,6
13C1:  BCF    0A,4
13C2:  BSF    0A,3
13C3:  CALL   780
13C4:  BSF    0A,4
13C5:  BCF    0A,3
....................             else if (idx == 2)          // Scaled ADC value for slider 2 
13C6:  GOTO   46D
13C7:  MOVLW  02
13C8:  BSF    03,6
13C9:  SUBWF  37,W
13CA:  BTFSC  03,2
13CB:  GOTO   3CE
13CC:  BCF    03,6
13CD:  GOTO   3EF
13CE:  BCF    03,6
....................                 printf(putnic_checkbyte, "%u", (BYTE)(adc2/11)+6); 
13CF:  MOVF   24,W
13D0:  BSF    03,6
13D1:  MOVWF  3D
13D2:  BCF    03,6
13D3:  MOVF   23,W
13D4:  BSF    03,6
13D5:  MOVWF  3C
13D6:  MOVLW  00
13D7:  MOVWF  3F
13D8:  MOVLW  0B
13D9:  MOVWF  3E
13DA:  BCF    03,6
13DB:  BCF    0A,4
13DC:  BSF    0A,3
13DD:  CALL   743
13DE:  BSF    0A,4
13DF:  BCF    0A,3
13E0:  MOVLW  06
13E1:  ADDWF  78,W
13E2:  BSF    03,6
13E3:  MOVWF  39
13E4:  MOVF   39,W
13E5:  MOVWF  3A
13E6:  MOVLW  0C
13E7:  MOVWF  3B
13E8:  BCF    03,6
13E9:  BCF    0A,4
13EA:  BSF    0A,3
13EB:  CALL   780
13EC:  BSF    0A,4
13ED:  BCF    0A,3
....................             else if (idx == 3)          // Voltage value for ADC 1 
13EE:  GOTO   46D
13EF:  MOVLW  03
13F0:  BSF    03,6
13F1:  SUBWF  37,W
13F2:  BTFSC  03,2
13F3:  GOTO   3F6
13F4:  BCF    03,6
13F5:  GOTO   401
13F6:  BCF    03,6
....................                 putnic_volts(adc1); 
13F7:  MOVF   22,W
13F8:  BSF    03,6
13F9:  MOVWF  3A
13FA:  BCF    03,6
13FB:  MOVF   21,W
13FC:  BSF    03,6
13FD:  MOVWF  39
13FE:  BCF    03,6
13FF:  CALL   1C3
....................             else if (idx == 4)          // Voltage value for ADC 2 
1400:  GOTO   46D
1401:  MOVLW  04
1402:  BSF    03,6
1403:  SUBWF  37,W
1404:  BTFSC  03,2
1405:  GOTO   408
1406:  BCF    03,6
1407:  GOTO   413
1408:  BCF    03,6
....................                 putnic_volts(adc2); 
1409:  MOVF   24,W
140A:  BSF    03,6
140B:  MOVWF  3A
140C:  BCF    03,6
140D:  MOVF   23,W
140E:  BSF    03,6
140F:  MOVWF  39
1410:  BCF    03,6
1411:  CALL   1C3
....................             else if (idx == 5)          // User O/P LED 1 state 
1412:  GOTO   46D
1413:  MOVLW  05
1414:  BSF    03,6
1415:  SUBWF  37,W
1416:  BTFSC  03,2
1417:  GOTO   41A
1418:  BCF    03,6
1419:  GOTO   42B
141A:  BCF    03,6
....................                 putnic_checkbyte(USERLED1 ? '0' : '1'); 
141B:  BTFSS  05,2
141C:  GOTO   41F
141D:  MOVLW  30
141E:  GOTO   420
141F:  MOVLW  31
1420:  BSF    03,6
1421:  MOVWF  39
1422:  MOVF   39,W
1423:  MOVWF  3D
1424:  BCF    03,6
1425:  BCF    0A,4
1426:  BSF    0A,3
1427:  CALL   735
1428:  BSF    0A,4
1429:  BCF    0A,3
....................             else if (idx == 6)          // User O/P LED 2 state 
142A:  GOTO   46D
142B:  MOVLW  06
142C:  BSF    03,6
142D:  SUBWF  37,W
142E:  BTFSC  03,2
142F:  GOTO   432
1430:  BCF    03,6
1431:  GOTO   443
1432:  BCF    03,6
....................                 putnic_checkbyte(USERLED2 ? '0' : '1'); 
1433:  BTFSS  05,3
1434:  GOTO   437
1435:  MOVLW  30
1436:  GOTO   438
1437:  MOVLW  31
1438:  BSF    03,6
1439:  MOVWF  39
143A:  MOVF   39,W
143B:  MOVWF  3D
143C:  BCF    03,6
143D:  BCF    0A,4
143E:  BSF    0A,3
143F:  CALL   735
1440:  BSF    0A,4
1441:  BCF    0A,3
....................             else if (idx == 7)          // I/P button state 
1442:  GOTO   46D
1443:  MOVLW  07
1444:  BSF    03,6
1445:  SUBWF  37,W
1446:  BTFSC  03,2
1447:  GOTO   44A
1448:  BCF    03,6
1449:  GOTO   45B
144A:  BCF    03,6
....................                 putnic_checkbyte(USER_BUTTON ? '0' : '1'); 
144B:  BTFSS  06,5
144C:  GOTO   44F
144D:  MOVLW  30
144E:  GOTO   450
144F:  MOVLW  31
1450:  BSF    03,6
1451:  MOVWF  39
1452:  MOVF   39,W
1453:  MOVWF  3D
1454:  BCF    03,6
1455:  BCF    0A,4
1456:  BSF    0A,3
1457:  CALL   735
1458:  BSF    0A,4
1459:  BCF    0A,3
....................             else                        // Unknown variable 
145A:  GOTO   46D
....................                 printf(putnic_checkbyte, "??"); 
145B:  MOVLW  3F
145C:  BSF    03,6
145D:  MOVWF  3D
145E:  BCF    03,6
145F:  BCF    0A,4
1460:  BSF    0A,3
1461:  CALL   735
1462:  BSF    0A,4
1463:  BCF    0A,3
1464:  MOVLW  3F
1465:  BSF    03,6
1466:  MOVWF  3D
1467:  BCF    03,6
1468:  BCF    0A,4
1469:  BSF    0A,3
146A:  CALL   735
146B:  BSF    0A,4
146C:  BCF    0A,3
....................         } 
....................         else                            // Non-EGI byte; send out unmodified 
146D:  GOTO   477
....................             putnic_checkbyte(b); 
146E:  BSF    03,6
146F:  MOVF   38,W
1470:  MOVWF  3D
1471:  BCF    03,6
1472:  BCF    0A,4
1473:  BSF    0A,3
1474:  CALL   735
1475:  BSF    0A,4
1476:  BCF    0A,3
....................         romdir.f.len--;                 // Decrement length 
1477:  BSF    03,6
1478:  MOVF   10,W
1479:  BTFSC  03,2
147A:  DECF   11,F
147B:  DECF   10,F
....................         ret = 1; 
147C:  MOVLW  01
147D:  MOVWF  36
147E:  BCF    03,6
....................     } 
....................     return(ret); 
147F:  BSF    03,6
1480:  MOVF   36,W
1481:  BCF    03,6
1482:  MOVWF  78
.................... } 
....................  
.................... /* Send the voltage string for the given ADC to the NIC */ 
.................... void putnic_volts(WORD val) 
.................... {              
....................     BYTE v; 
....................      
....................     v = (BYTE)(val / 21); 
*
11C3:  BSF    03,6
11C4:  MOVF   3A,W
11C5:  MOVWF  3D
11C6:  MOVF   39,W
11C7:  MOVWF  3C
11C8:  MOVLW  00
11C9:  MOVWF  3F
11CA:  MOVLW  15
11CB:  MOVWF  3E
11CC:  BCF    03,6
11CD:  BCF    0A,4
11CE:  BSF    0A,3
11CF:  CALL   743
11D0:  BSF    0A,4
11D1:  BCF    0A,3
11D2:  MOVF   78,W
11D3:  BSF    03,6
11D4:  MOVWF  3B
....................     putnic_checkbyte(v/10 + '0'); 
11D5:  MOVF   3B,W
11D6:  MOVWF  3C
11D7:  MOVLW  0A
11D8:  MOVWF  3D
11D9:  BCF    03,6
11DA:  BCF    0A,4
11DB:  CALL   7D6
11DC:  BSF    0A,4
11DD:  MOVLW  30
11DE:  ADDWF  78,W
11DF:  BSF    03,6
11E0:  MOVWF  3C
11E1:  MOVF   3C,W
11E2:  MOVWF  3D
11E3:  BCF    03,6
11E4:  BCF    0A,4
11E5:  BSF    0A,3
11E6:  CALL   735
11E7:  BSF    0A,4
11E8:  BCF    0A,3
....................     putnic_checkbyte('.'); 
11E9:  MOVLW  2E
11EA:  BSF    03,6
11EB:  MOVWF  3D
11EC:  BCF    03,6
11ED:  BCF    0A,4
11EE:  BSF    0A,3
11EF:  CALL   735
11F0:  BSF    0A,4
11F1:  BCF    0A,3
....................     putnic_checkbyte(v%10 + '0'); 
11F2:  BSF    03,6
11F3:  MOVF   3B,W
11F4:  MOVWF  3C
11F5:  MOVLW  0A
11F6:  MOVWF  3D
11F7:  BCF    03,6
11F8:  BCF    0A,4
11F9:  CALL   7D6
11FA:  BSF    0A,4
11FB:  MOVLW  30
11FC:  ADDWF  77,W
11FD:  BSF    03,6
11FE:  MOVWF  3C
11FF:  MOVF   3C,W
1200:  MOVWF  3D
1201:  BCF    03,6
1202:  BCF    0A,4
1203:  BSF    0A,3
1204:  CALL   735
1205:  BSF    0A,4
1206:  BCF    0A,3
1207:  RETLW  00
.................... } 
....................  
.................... /* EOF */
.................... #include "\chipweb\pcm\p16_usr.h" 
....................  /* User console interface functions for CHIPWEB 
.................... ** Copyright (c) Iosoft Ltd 2001 
.................... ** This software is only licensed for distribution in the Iosoft ChipWeb package 
.................... ** and may only be used for personal experimentation by the purchaser  
.................... ** of that package, on condition that this copyright notice is retained.  
.................... ** For commercial licensing, contact license@iosoft.co.uk 
.................... ** 
.................... ** This is experimental software; use it entirely at your own risk */ 
....................                              
.................... #define SOH 0x01 
.................... #define EOT 0x04 
.................... #define ACK 0x06 
.................... #define NAK 0x15 
.................... #define CAN 0x18 
....................  
.................... #define ROMPAGE_LEN 32 
.................... #define XBLOCK_LEN  128 
....................                              
.................... BOOL escaped; 
....................  
.................... WORD getnum(void); 
.................... void write_nonvol(void); 
.................... void xmodem_recv(void); 
....................  
.................... /* User initialisation code; get serial number and IP address 
.................... ** Skip if user hits ESC */ 
.................... void user_config(void) 
.................... {                      
....................     WORD w; 
....................     BYTE t1, t2; 
....................                             
....................     escaped = 0;                            
*
03EA:  BCF    26,6
....................     printf("\r\nSerial num? "); 
*
0089:  BCF    0A,0
008A:  BCF    0A,1
008B:  BCF    0A,2
008C:  ADDWF  02,F
008D:  RETLW  0D
008E:  RETLW  0A
008F:  RETLW  53
0090:  RETLW  65
0091:  RETLW  72
0092:  RETLW  69
0093:  RETLW  61
0094:  RETLW  6C
0095:  RETLW  20
0096:  RETLW  6E
0097:  RETLW  75
0098:  RETLW  6D
0099:  RETLW  3F
009A:  RETLW  20
009B:  RETLW  00
*
03EB:  BSF    03,6
03EC:  CLRF   29
03ED:  BCF    03,6
03EE:  BSF    03,6
03EF:  MOVF   29,W
03F0:  BCF    03,6
03F1:  CALL   089
03F2:  BSF    03,6
03F3:  INCF   29,F
03F4:  BCF    03,6
03F5:  BTFSS  0C,4
03F6:  GOTO   3F5
03F7:  MOVWF  19
03F8:  MOVLW  0E
03F9:  BSF    03,6
03FA:  SUBWF  29,W
03FB:  BTFSC  03,2
03FC:  GOTO   3FF
03FD:  BCF    03,6
03FE:  GOTO   3EE
....................     w = getnum(); 
03FF:  BCF    03,6
0400:  CALL   2EF
0401:  MOVF   79,W
0402:  BSF    03,6
0403:  MOVWF  26
0404:  BCF    03,6
0405:  MOVF   78,W
0406:  BSF    03,6
0407:  MOVWF  25
....................     if (!escaped) 
0408:  BCF    03,6
0409:  BTFSC  26,6
040A:  GOTO   413
....................     { 
....................         myeth[4] = w >> 8; 
040B:  BSF    03,6
040C:  MOVF   26,W
040D:  BCF    03,6
040E:  MOVWF  2E
....................         myeth[5] = w; 
040F:  BSF    03,6
0410:  MOVF   25,W
0411:  BCF    03,6
0412:  MOVWF  2F
....................     } 
....................     escaped = 0; 
0413:  BCF    26,6
....................     printf("\r\nIP addr? "); 
*
009C:  BCF    0A,0
009D:  BCF    0A,1
009E:  BCF    0A,2
009F:  ADDWF  02,F
00A0:  RETLW  0D
00A1:  RETLW  0A
00A2:  RETLW  49
00A3:  RETLW  50
00A4:  RETLW  20
00A5:  RETLW  61
00A6:  RETLW  64
00A7:  RETLW  64
00A8:  RETLW  72
00A9:  RETLW  3F
00AA:  RETLW  20
00AB:  RETLW  00
*
0414:  BSF    03,6
0415:  CLRF   29
0416:  BCF    03,6
0417:  BSF    03,6
0418:  MOVF   29,W
0419:  BCF    03,6
041A:  CALL   09C
041B:  BSF    03,6
041C:  INCF   29,F
041D:  BCF    03,6
041E:  BTFSS  0C,4
041F:  GOTO   41E
0420:  MOVWF  19
0421:  MOVLW  0B
0422:  BSF    03,6
0423:  SUBWF  29,W
0424:  BTFSC  03,2
0425:  GOTO   428
0426:  BCF    03,6
0427:  GOTO   417
....................     USERLED1 = USERLED2 = 1; 
0428:  BCF    03,6
0429:  BSF    05,3
042A:  BSF    05,2
....................     myip.b[3] = getnum(); 
042B:  CALL   2EF
042C:  MOVF   78,W
042D:  MOVWF  51
....................     putchar('.'); 
042E:  MOVLW  2E
042F:  BTFSS  0C,4
0430:  GOTO   42F
0431:  MOVWF  19
....................     if (!escaped) 
0432:  BTFSC  26,6
0433:  GOTO   437
....................         myip.b[2] = getnum(); 
0434:  CALL   2EF
0435:  MOVF   78,W
0436:  MOVWF  50
....................     putchar('.'); 
0437:  MOVLW  2E
0438:  BTFSS  0C,4
0439:  GOTO   438
043A:  MOVWF  19
....................     if (!escaped) 
043B:  BTFSC  26,6
043C:  GOTO   440
....................         myip.b[1] = getnum(); 
043D:  CALL   2EF
043E:  MOVF   78,W
043F:  MOVWF  4F
....................     putchar('.'); 
0440:  MOVLW  2E
0441:  BTFSS  0C,4
0442:  GOTO   441
0443:  MOVWF  19
....................     if (!escaped) 
0444:  BTFSC  26,6
0445:  GOTO   449
....................         myip.b[0] = getnum(); 
0446:  CALL   2EF
0447:  MOVF   78,W
0448:  MOVWF  4E
....................     if (!escaped) 
0449:  BTFSC  26,6
044A:  GOTO   539
....................         write_nonvol(); 
....................     printf("\r\nXmodem? "); 
*
00AC:  BCF    0A,0
00AD:  BCF    0A,1
00AE:  BCF    0A,2
00AF:  ADDWF  02,F
00B0:  RETLW  0D
00B1:  RETLW  0A
00B2:  RETLW  58
00B3:  RETLW  6D
00B4:  RETLW  6F
00B5:  RETLW  64
00B6:  RETLW  65
00B7:  RETLW  6D
00B8:  RETLW  3F
00B9:  RETLW  20
00BA:  RETLW  00
*
0539:  BSF    03,6
053A:  CLRF   29
053B:  BCF    03,6
053C:  BSF    03,6
053D:  MOVF   29,W
053E:  BCF    03,6
053F:  CALL   0AC
0540:  BSF    03,6
0541:  INCF   29,F
0542:  BCF    03,6
0543:  BTFSS  0C,4
0544:  GOTO   543
0545:  MOVWF  19
0546:  MOVLW  0A
0547:  BSF    03,6
0548:  SUBWF  29,W
0549:  BTFSC  03,2
054A:  GOTO   54D
054B:  BCF    03,6
054C:  GOTO   53C
....................     xmodem_recv(); 
*
069F:  BCF    0A,3
06A0:  BSF    0A,4
06A1:  GOTO   570
.................... } 
....................  
.................... /* Get a 16-bit decimal number from the console 
.................... ** Return it when any non-numeric key is pressed (except backspace) */ 
.................... WORD getnum(void) 
.................... { 
....................     WORD val=0; 
....................     char c, buff[5]; 
*
02EF:  BSF    03,6
02F0:  CLRF   29
02F1:  CLRF   2A
02F2:  CLRF   31
02F3:  CLRF   32
02F4:  BCF    03,6
....................     int n=0, i=0; 
....................      
....................     do { 
....................         while (!kbhit()) 
02F5:  BTFSC  0C,5
02F6:  GOTO   2F9
....................             scan_io(); 
02F7:  CALL   265
02F8:  GOTO   2F5
....................         c = getchar(); 
02F9:  CALL   2BF
02FA:  MOVF   78,W
02FB:  BSF    03,6
02FC:  MOVWF  2B
....................         if (c == 0x1b) 
02FD:  MOVLW  1B
02FE:  SUBWF  2B,W
02FF:  BTFSC  03,2
0300:  GOTO   303
0301:  BCF    03,6
0302:  GOTO   306
0303:  BCF    03,6
....................             escaped = 1; 
0304:  BSF    26,6
....................         else if (c>='0' && c<='9') 
0305:  GOTO   362
0306:  MOVLW  30
0307:  BSF    03,6
0308:  SUBWF  2B,W
0309:  BTFSC  03,0
030A:  GOTO   30D
030B:  BCF    03,6
030C:  GOTO   338
030D:  BCF    03,6
030E:  MOVLW  3A
030F:  BSF    03,6
0310:  SUBWF  2B,W
0311:  BTFSS  03,0
0312:  GOTO   315
0313:  BCF    03,6
0314:  GOTO   338
0315:  BCF    03,6
....................         { 
....................             if (n < sizeof(buff)) 
0316:  MOVLW  05
0317:  BSF    03,6
0318:  SUBWF  31,W
0319:  BTFSS  03,0
031A:  GOTO   31D
031B:  BCF    03,6
031C:  GOTO   337
031D:  BCF    03,6
....................             { 
....................                 buff[n++] = c; 
031E:  BSF    03,6
031F:  MOVF   31,W
0320:  INCF   31,F
0321:  BCF    03,6
0322:  MOVWF  77
0323:  MOVLW  2C
0324:  ADDWF  77,W
0325:  MOVWF  79
0326:  MOVLW  01
0327:  MOVWF  7A
0328:  MOVF   79,W
0329:  BTFSC  03,0
032A:  INCF   7A,F
032B:  MOVWF  04
032C:  BCF    03,7
032D:  BTFSC  7A,0
032E:  BSF    03,7
032F:  BSF    03,6
0330:  MOVF   2B,W
0331:  MOVWF  00
....................                 putchar(c); 
0332:  MOVF   2B,W
0333:  BCF    03,6
0334:  BTFSS  0C,4
0335:  GOTO   334
0336:  MOVWF  19
....................             } 
....................         } 
....................         else if (c=='\b' || c==0x7f) 
0337:  GOTO   362
0338:  MOVLW  08
0339:  BSF    03,6
033A:  SUBWF  2B,W
033B:  BTFSS  03,2
033C:  GOTO   33F
033D:  BCF    03,6
033E:  GOTO   348
033F:  BCF    03,6
0340:  MOVLW  7F
0341:  BSF    03,6
0342:  SUBWF  2B,W
0343:  BTFSC  03,2
0344:  GOTO   347
0345:  BCF    03,6
0346:  GOTO   35F
0347:  BCF    03,6
....................         { 
....................             if (n > 0) 
0348:  BSF    03,6
0349:  MOVF   31,F
034A:  BTFSS  03,2
034B:  GOTO   34E
034C:  BCF    03,6
034D:  GOTO   35E
034E:  BCF    03,6
....................             { 
....................                 n--; 
034F:  BSF    03,6
0350:  DECF   31,F
....................                 putchar('\b'); 
0351:  MOVLW  08
0352:  BCF    03,6
0353:  BTFSS  0C,4
0354:  GOTO   353
0355:  MOVWF  19
....................                 putchar(' '); 
0356:  MOVLW  20
0357:  BTFSS  0C,4
0358:  GOTO   357
0359:  MOVWF  19
....................                 putchar('\b'); 
035A:  MOVLW  08
035B:  BTFSS  0C,4
035C:  GOTO   35B
035D:  MOVWF  19
....................             } 
....................         } 
....................         else  
035E:  GOTO   362
....................             c = 0; 
035F:  BSF    03,6
0360:  CLRF   2B
0361:  BCF    03,6
....................     } while (c && !escaped); 
0362:  BSF    03,6
0363:  MOVF   2B,F
0364:  BTFSS  03,2
0365:  GOTO   368
0366:  BCF    03,6
0367:  GOTO   36B
0368:  BCF    03,6
0369:  BTFSS  26,6
036A:  GOTO   2F5
....................     while (n--) 
036B:  BSF    03,6
036C:  MOVF   31,W
036D:  DECF   31,F
036E:  IORLW  00
036F:  BTFSS  03,2
0370:  GOTO   373
0371:  BCF    03,6
0372:  GOTO   3A7
0373:  BCF    03,6
....................         val = (val * 10) + buff[i++] - '0'; 
*
02CB:  MOVLW  10
02CC:  MOVWF  77
02CD:  CLRF   7A
02CE:  BSF    03,6
02CF:  CLRF   37
02D0:  BCF    03,6
02D1:  BSF    03,6
02D2:  RRF    34,F
02D3:  RRF    33,F
02D4:  BTFSC  03,0
02D5:  GOTO   2D8
02D6:  BCF    03,6
02D7:  GOTO   2E4
02D8:  MOVF   35,W
02D9:  BCF    03,6
02DA:  ADDWF  7A,F
02DB:  BTFSS  03,0
02DC:  GOTO   2E0
02DD:  BSF    03,6
02DE:  INCF   37,F
02DF:  BCF    03,6
02E0:  BSF    03,6
02E1:  MOVF   36,W
02E2:  ADDWF  37,F
02E3:  BCF    03,6
02E4:  BSF    03,6
02E5:  RRF    37,F
02E6:  BCF    03,6
02E7:  RRF    7A,F
02E8:  RRF    79,F
02E9:  RRF    78,F
02EA:  DECFSZ 77,F
02EB:  GOTO   2D1
02EC:  BCF    0A,3
02ED:  BCF    0A,4
02EE:  GOTO   37F
*
0374:  BSF    03,6
0375:  MOVF   2A,W
0376:  MOVWF  34
0377:  MOVF   29,W
0378:  MOVWF  33
0379:  MOVLW  00
037A:  MOVWF  36
037B:  MOVLW  0A
037C:  MOVWF  35
037D:  BCF    03,6
037E:  GOTO   2CB
037F:  MOVF   79,W
0380:  BSF    03,6
0381:  MOVWF  34
0382:  BCF    03,6
0383:  MOVF   78,W
0384:  BSF    03,6
0385:  MOVWF  33
0386:  MOVF   32,W
0387:  INCF   32,F
0388:  BCF    03,6
0389:  MOVWF  77
038A:  MOVLW  2C
038B:  ADDWF  77,W
038C:  MOVWF  79
038D:  MOVLW  01
038E:  MOVWF  7A
038F:  MOVF   79,W
0390:  BTFSC  03,0
0391:  INCF   7A,F
0392:  MOVWF  04
0393:  BCF    03,7
0394:  BTFSC  7A,0
0395:  BSF    03,7
0396:  MOVF   00,W
0397:  BSF    03,6
0398:  ADDWF  33,F
0399:  BTFSC  03,0
039A:  INCF   34,F
039B:  MOVF   33,W
039C:  MOVWF  29
039D:  MOVLW  30
039E:  SUBWF  29,F
039F:  MOVF   34,W
03A0:  MOVWF  2A
03A1:  MOVLW  00
03A2:  BTFSS  03,0
03A3:  DECF   2A,F
03A4:  SUBWF  2A,F
03A5:  BCF    03,6
03A6:  GOTO   36B
....................     return(val); 
03A7:  BSF    03,6
03A8:  MOVF   29,W
03A9:  BCF    03,6
03AA:  MOVWF  78
03AB:  BSF    03,6
03AC:  MOVF   2A,W
03AD:  BCF    03,6
03AE:  MOVWF  79
03AF:  RETLW  00
.................... } 
....................  
.................... /* Read in the nonvolatile parameters, return 0 if error */ 
.................... BOOL read_nonvol(void) 
.................... {         
....................     int i; 
....................                        
....................     myeth[4] = read_eeprom(0); 
*
01FA:  BSF    03,6
01FB:  CLRF   0D
01FC:  CLRF   0F
01FD:  BSF    03,5
01FE:  BCF    0C,7
01FF:  BSF    0C,0
0200:  BCF    03,5
0201:  MOVF   0C,W
0202:  BCF    03,6
0203:  MOVWF  2E
....................     myeth[5] = read_eeprom(1); 
0204:  MOVLW  01
0205:  BSF    03,6
0206:  MOVWF  0D
0207:  CLRF   0F
0208:  BSF    03,5
0209:  BCF    0C,7
020A:  BSF    0C,0
020B:  BCF    03,5
020C:  MOVF   0C,W
020D:  BCF    03,6
020E:  MOVWF  2F
....................     myip.b[3] = read_eeprom(2); 
020F:  MOVLW  02
0210:  BSF    03,6
0211:  MOVWF  0D
0212:  CLRF   0F
0213:  BSF    03,5
0214:  BCF    0C,7
0215:  BSF    0C,0
0216:  BCF    03,5
0217:  MOVF   0C,W
0218:  BCF    03,6
0219:  MOVWF  51
....................     myip.b[2] = read_eeprom(3); 
021A:  MOVLW  03
021B:  BSF    03,6
021C:  MOVWF  0D
021D:  CLRF   0F
021E:  BSF    03,5
021F:  BCF    0C,7
0220:  BSF    0C,0
0221:  BCF    03,5
0222:  MOVF   0C,W
0223:  BCF    03,6
0224:  MOVWF  50
....................     myip.b[1] = read_eeprom(4); 
0225:  MOVLW  04
0226:  BSF    03,6
0227:  MOVWF  0D
0228:  CLRF   0F
0229:  BSF    03,5
022A:  BCF    0C,7
022B:  BSF    0C,0
022C:  BCF    03,5
022D:  MOVF   0C,W
022E:  BCF    03,6
022F:  MOVWF  4F
....................     myip.b[0] = read_eeprom(5); 
0230:  MOVLW  05
0231:  BSF    03,6
0232:  MOVWF  0D
0233:  CLRF   0F
0234:  BSF    03,5
0235:  BCF    0C,7
0236:  BSF    0C,0
0237:  BCF    03,5
0238:  MOVF   0C,W
0239:  BCF    03,6
023A:  MOVWF  4E
....................     return (csum_nonvol() == read_eeprom(6)); 
023B:  CALL   1D9
023C:  MOVF   78,W
023D:  BSF    03,6
023E:  MOVWF  26
023F:  MOVLW  06
0240:  MOVWF  0D
0241:  CLRF   0F
0242:  BSF    03,5
0243:  BCF    0C,7
0244:  BSF    0C,0
0245:  BCF    03,5
0246:  MOVF   0C,W
0247:  SUBWF  26,W
0248:  BTFSS  03,2
0249:  GOTO   24C
024A:  BCF    03,6
024B:  GOTO   24F
024C:  BCF    03,6
024D:  MOVLW  00
024E:  GOTO   250
024F:  MOVLW  01
0250:  MOVWF  78
0251:  BCF    0A,3
0252:  BSF    0A,4
0253:  GOTO   550
.................... } 
....................  
.................... /* Write out the nonvolatile parameters */ 
.................... void write_nonvol(void) 
.................... { 
....................     write_eeprom(0, myeth[4]); 
*
044B:  BSF    03,6
044C:  CLRF   0D
044D:  CLRF   0F
044E:  BCF    03,6
044F:  MOVF   2E,W
0450:  BSF    03,6
0451:  MOVWF  0C
0452:  BSF    03,5
0453:  BCF    0C,7
0454:  BSF    0C,2
0455:  BCF    03,5
0456:  BCF    03,6
0457:  BCF    0B,7
0458:  MOVLW  55
0459:  BSF    03,5
045A:  BSF    03,6
045B:  MOVWF  0D
045C:  MOVLW  AA
045D:  MOVWF  0D
045E:  BSF    0C,1
045F:  BCF    03,5
0460:  BCF    03,6
0461:  BSF    03,5
0462:  BSF    03,6
0463:  BTFSS  0C,1
0464:  GOTO   468
0465:  BCF    03,5
0466:  BCF    03,6
0467:  GOTO   461
0468:  BCF    0C,2
0469:  BCF    03,5
046A:  BCF    03,6
046B:  BSF    0B,7
....................     write_eeprom(1, myeth[5]); 
046C:  MOVLW  01
046D:  BSF    03,6
046E:  MOVWF  0D
046F:  CLRF   0F
0470:  BCF    03,6
0471:  MOVF   2F,W
0472:  BSF    03,6
0473:  MOVWF  0C
0474:  BSF    03,5
0475:  BCF    0C,7
0476:  BSF    0C,2
0477:  BCF    03,5
0478:  BCF    03,6
0479:  BCF    0B,7
047A:  MOVLW  55
047B:  BSF    03,5
047C:  BSF    03,6
047D:  MOVWF  0D
047E:  MOVLW  AA
047F:  MOVWF  0D
0480:  BSF    0C,1
0481:  BCF    03,5
0482:  BCF    03,6
0483:  BSF    03,5
0484:  BSF    03,6
0485:  BTFSS  0C,1
0486:  GOTO   48A
0487:  BCF    03,5
0488:  BCF    03,6
0489:  GOTO   483
048A:  BCF    0C,2
048B:  BCF    03,5
048C:  BCF    03,6
048D:  BSF    0B,7
....................     write_eeprom(2, myip.b[3]); 
048E:  MOVLW  02
048F:  BSF    03,6
0490:  MOVWF  0D
0491:  CLRF   0F
0492:  BCF    03,6
0493:  MOVF   51,W
0494:  BSF    03,6
0495:  MOVWF  0C
0496:  BSF    03,5
0497:  BCF    0C,7
0498:  BSF    0C,2
0499:  BCF    03,5
049A:  BCF    03,6
049B:  BCF    0B,7
049C:  MOVLW  55
049D:  BSF    03,5
049E:  BSF    03,6
049F:  MOVWF  0D
04A0:  MOVLW  AA
04A1:  MOVWF  0D
04A2:  BSF    0C,1
04A3:  BCF    03,5
04A4:  BCF    03,6
04A5:  BSF    03,5
04A6:  BSF    03,6
04A7:  BTFSS  0C,1
04A8:  GOTO   4AC
04A9:  BCF    03,5
04AA:  BCF    03,6
04AB:  GOTO   4A5
04AC:  BCF    0C,2
04AD:  BCF    03,5
04AE:  BCF    03,6
04AF:  BSF    0B,7
....................     write_eeprom(3, myip.b[2]); 
04B0:  MOVLW  03
04B1:  BSF    03,6
04B2:  MOVWF  0D
04B3:  CLRF   0F
04B4:  BCF    03,6
04B5:  MOVF   50,W
04B6:  BSF    03,6
04B7:  MOVWF  0C
04B8:  BSF    03,5
04B9:  BCF    0C,7
04BA:  BSF    0C,2
04BB:  BCF    03,5
04BC:  BCF    03,6
04BD:  BCF    0B,7
04BE:  MOVLW  55
04BF:  BSF    03,5
04C0:  BSF    03,6
04C1:  MOVWF  0D
04C2:  MOVLW  AA
04C3:  MOVWF  0D
04C4:  BSF    0C,1
04C5:  BCF    03,5
04C6:  BCF    03,6
04C7:  BSF    03,5
04C8:  BSF    03,6
04C9:  BTFSS  0C,1
04CA:  GOTO   4CE
04CB:  BCF    03,5
04CC:  BCF    03,6
04CD:  GOTO   4C7
04CE:  BCF    0C,2
04CF:  BCF    03,5
04D0:  BCF    03,6
04D1:  BSF    0B,7
....................     write_eeprom(4, myip.b[1]); 
04D2:  MOVLW  04
04D3:  BSF    03,6
04D4:  MOVWF  0D
04D5:  CLRF   0F
04D6:  BCF    03,6
04D7:  MOVF   4F,W
04D8:  BSF    03,6
04D9:  MOVWF  0C
04DA:  BSF    03,5
04DB:  BCF    0C,7
04DC:  BSF    0C,2
04DD:  BCF    03,5
04DE:  BCF    03,6
04DF:  BCF    0B,7
04E0:  MOVLW  55
04E1:  BSF    03,5
04E2:  BSF    03,6
04E3:  MOVWF  0D
04E4:  MOVLW  AA
04E5:  MOVWF  0D
04E6:  BSF    0C,1
04E7:  BCF    03,5
04E8:  BCF    03,6
04E9:  BSF    03,5
04EA:  BSF    03,6
04EB:  BTFSS  0C,1
04EC:  GOTO   4F0
04ED:  BCF    03,5
04EE:  BCF    03,6
04EF:  GOTO   4E9
04F0:  BCF    0C,2
04F1:  BCF    03,5
04F2:  BCF    03,6
04F3:  BSF    0B,7
....................     write_eeprom(5, myip.b[0]); 
04F4:  MOVLW  05
04F5:  BSF    03,6
04F6:  MOVWF  0D
04F7:  CLRF   0F
04F8:  BCF    03,6
04F9:  MOVF   4E,W
04FA:  BSF    03,6
04FB:  MOVWF  0C
04FC:  BSF    03,5
04FD:  BCF    0C,7
04FE:  BSF    0C,2
04FF:  BCF    03,5
0500:  BCF    03,6
0501:  BCF    0B,7
0502:  MOVLW  55
0503:  BSF    03,5
0504:  BSF    03,6
0505:  MOVWF  0D
0506:  MOVLW  AA
0507:  MOVWF  0D
0508:  BSF    0C,1
0509:  BCF    03,5
050A:  BCF    03,6
050B:  BSF    03,5
050C:  BSF    03,6
050D:  BTFSS  0C,1
050E:  GOTO   512
050F:  BCF    03,5
0510:  BCF    03,6
0511:  GOTO   50B
0512:  BCF    0C,2
0513:  BCF    03,5
0514:  BCF    03,6
0515:  BSF    0B,7
....................     write_eeprom(6, csum_nonvol()); 
0516:  CALL   1D9
0517:  MOVF   78,W
0518:  BSF    03,6
0519:  MOVWF  29
051A:  MOVLW  06
051B:  MOVWF  0D
051C:  CLRF   0F
051D:  MOVF   29,W
051E:  MOVWF  0C
051F:  BSF    03,5
0520:  BCF    0C,7
0521:  BSF    0C,2
0522:  BCF    03,5
0523:  BCF    03,6
0524:  BCF    0B,7
0525:  MOVLW  55
0526:  BSF    03,5
0527:  BSF    03,6
0528:  MOVWF  0D
0529:  MOVLW  AA
052A:  MOVWF  0D
052B:  BSF    0C,1
052C:  BCF    03,5
052D:  BCF    03,6
052E:  BSF    03,5
052F:  BSF    03,6
0530:  BTFSS  0C,1
0531:  GOTO   535
0532:  BCF    03,5
0533:  BCF    03,6
0534:  GOTO   52E
0535:  BCF    0C,2
0536:  BCF    03,5
0537:  BCF    03,6
0538:  BSF    0B,7
.................... } 
....................  
.................... /* Do a 1's omplement checksum of the non-volatile data */ 
.................... BYTE csum_nonvol(void) 
.................... { 
....................     int i; 
*
01D9:  BSF    03,6
01DA:  CLRF   2A
....................     BYTE sum=0; 
....................      
....................     for (i=0; i<6; i++) 
01DB:  CLRF   29
01DC:  BCF    03,6
01DD:  MOVLW  06
01DE:  BSF    03,6
01DF:  SUBWF  29,W
01E0:  BTFSS  03,0
01E1:  GOTO   1E4
01E2:  BCF    03,6
01E3:  GOTO   1F4
01E4:  BCF    03,6
....................         sum += read_eeprom(i); 
01E5:  BSF    03,6
01E6:  MOVF   29,W
01E7:  MOVWF  0D
01E8:  CLRF   0F
01E9:  BSF    03,5
01EA:  BCF    0C,7
01EB:  BSF    0C,0
01EC:  BCF    03,5
01ED:  MOVF   0C,W
01EE:  ADDWF  2A,F
01EF:  BCF    03,6
01F0:  BSF    03,6
01F1:  INCF   29,F
01F2:  BCF    03,6
01F3:  GOTO   1DD
....................     return(~sum); 
01F4:  BSF    03,6
01F5:  MOVF   2A,W
01F6:  XORLW  FF
01F7:  BCF    03,6
01F8:  MOVWF  78
01F9:  RETLW  00
.................... } 
....................  
.................... /* Handle incoming XMODEM data block */ 
.................... void xmodem_recv(void) 
.................... {      
....................     BYTE b, len=0, idx, blk, i, oset; 
*
054D:  CLRF   2A
054E:  BCF    2F,0
054F:  BCF    2F,1
0550:  BCF    2F,2
0551:  BCF    2F,3
....................     BOOL rxing=FALSE, b1=FALSE, b2=FALSE, b3=FALSE; 
....................       
....................     timeout(ledticks, 0); 
0552:  CLRF   35
....................     while (1)  
....................     { 
....................         while (!kbhit()) 
*
0572:  BTFSC  0C,5
0573:  GOTO   5B2
....................         { 
....................             restart_wdt();              // Kick watchdog 
0574:  CLRWDT
....................             geticks();                  // Check for timeout 
0575:  CALL   254
....................             if (timeout(ledticks, LEDTIME)) 
0576:  MOVLW  0A
0577:  BSF    03,6
0578:  MOVWF  35
*
0598:  MOVF   78,F
0599:  BTFSC  03,2
059A:  GOTO   5B1
....................             { 
....................                 SYSLED = !SYSLED; 
059B:  MOVLW  10
059C:  XORWF  05,F
....................                 USERLED1 = 1; 
059D:  BSF    05,2
....................                 if (!rxing)             // Send NAK if idle 
059E:  BSF    03,6
059F:  BTFSS  2F,0
05A0:  GOTO   5A3
05A1:  BCF    03,6
05A2:  GOTO   5AE
05A3:  BCF    03,6
....................                 { 
....................                     len = 0; 
05A4:  BSF    03,6
05A5:  CLRF   2A
....................                     b1 = b2 = b3 = FALSE; 
05A6:  BCF    2F,3
05A7:  BCF    2F,2
05A8:  BCF    2F,1
....................                     putchar(NAK); 
05A9:  MOVLW  15
05AA:  BCF    03,6
05AB:  BTFSS  0C,4
05AC:  GOTO   5AB
05AD:  MOVWF  19
....................                 } 
....................                 rxing = FALSE; 
05AE:  BSF    03,6
05AF:  BCF    2F,0
05B0:  BCF    03,6
....................             } 
....................         } 
05B1:  GOTO   572
....................         b = getchar();                  // Get character 
05B2:  CALL   2BF
05B3:  MOVF   78,W
05B4:  BSF    03,6
05B5:  MOVWF  29
....................         rxing = TRUE; 
05B6:  BSF    2F,0
....................         if (!b1)                        // Check if 1st char 
05B7:  BTFSS  2F,1
05B8:  GOTO   5BB
05B9:  BCF    03,6
05BA:  GOTO   5D6
05BB:  BCF    03,6
....................         { 
....................             if (b == SOH)               // ..if SOH, move on 
05BC:  MOVLW  01
05BD:  BSF    03,6
05BE:  SUBWF  29,W
05BF:  BTFSC  03,2
05C0:  GOTO   5C3
05C1:  BCF    03,6
05C2:  GOTO   5C8
05C3:  BCF    03,6
....................                 b1 = TRUE; 
05C4:  BSF    03,6
05C5:  BSF    2F,1
....................             else if (b == EOT)          // ..if EOT, we're done 
05C6:  BCF    03,6
05C7:  GOTO   5D5
05C8:  MOVLW  04
05C9:  BSF    03,6
05CA:  SUBWF  29,W
05CB:  BTFSC  03,2
05CC:  GOTO   5CF
05CD:  BCF    03,6
05CE:  GOTO   5D5
05CF:  BCF    03,6
....................             { 
....................                 putchar(ACK); 
05D0:  MOVLW  06
05D1:  BTFSS  0C,4
05D2:  GOTO   5D1
05D3:  MOVWF  19
....................                 break; 
05D4:  GOTO   69F
....................             } 
....................         } 
....................         else if (!b2)                   // Check if 2nd char 
05D5:  GOTO   69E
05D6:  BSF    03,6
05D7:  BTFSS  2F,2
05D8:  GOTO   5DB
05D9:  BCF    03,6
05DA:  GOTO   5E2
05DB:  BCF    03,6
....................         { 
....................             blk = b;                    // ..block num 
05DC:  BSF    03,6
05DD:  MOVF   29,W
05DE:  MOVWF  2C
....................             b2 = TRUE; 
05DF:  BSF    2F,2
....................         } 
....................         else if (!b3)                   // Check if 3rd char 
05E0:  BCF    03,6
05E1:  GOTO   69E
05E2:  BSF    03,6
05E3:  BTFSS  2F,3
05E4:  GOTO   5E7
05E5:  BCF    03,6
05E6:  GOTO   5F6
05E7:  BCF    03,6
....................         { 
....................             if (blk == ~b)              // ..inverse block num 
05E8:  BSF    03,6
05E9:  MOVF   29,W
05EA:  XORLW  FF
05EB:  SUBWF  2C,W
05EC:  BTFSC  03,2
05ED:  GOTO   5F0
05EE:  BCF    03,6
05EF:  GOTO   5F5
05F0:  BCF    03,6
....................             { 
....................                 b3 = TRUE; 
05F1:  BSF    03,6
05F2:  BSF    2F,3
....................                 blk--; 
05F3:  DECF   2C,F
05F4:  BCF    03,6
....................             } 
....................         } 
....................         else if (len < XBLOCK_LEN)      // Rest of chars up to block len 
05F5:  GOTO   69E
05F6:  MOVLW  80
05F7:  BSF    03,6
05F8:  SUBWF  2A,W
05F9:  BTFSS  03,0
05FA:  GOTO   5FD
05FB:  BCF    03,6
05FC:  GOTO   671
05FD:  BCF    03,6
....................         {                               // Buffer into ROM page 
....................             idx = len & (ROMPAGE_LEN - 1); 
05FE:  BSF    03,6
05FF:  MOVF   2A,W
0600:  ANDLW  1F
0601:  MOVWF  2B
....................             len++; 
0602:  INCF   2A,F
....................             txbuff[idx] = b;            // If end of ROM page.. 
0603:  MOVLW  A0
0604:  ADDWF  2B,W
0605:  BCF    03,6
0606:  MOVWF  04
0607:  BCF    03,7
0608:  BSF    03,6
0609:  MOVF   29,W
060A:  MOVWF  00
....................             if (idx == ROMPAGE_LEN-1)   // ..write to ROM 
060B:  MOVLW  1F
060C:  SUBWF  2B,W
060D:  BTFSC  03,2
060E:  GOTO   611
060F:  BCF    03,6
0610:  GOTO   670
0611:  BCF    03,6
....................             { 
....................                 i2c_start(); 
0612:  BSF    03,5
0613:  BSF    07,4
0614:  CLRWDT
0615:  BSF    07,3
0616:  CLRWDT
0617:  BCF    03,5
0618:  BCF    07,4
0619:  BSF    03,5
061A:  BCF    07,4
061B:  CLRWDT
061C:  BCF    03,5
061D:  BCF    07,3
061E:  BSF    03,5
061F:  BCF    07,3
....................                 i2c_write(EEROM_ADDR); 
0620:  MOVLW  A0
0621:  BCF    03,5
0622:  BSF    03,6
0623:  MOVWF  45
0624:  BCF    03,6
0625:  CALL   3B0
....................                 i2c_write(blk >> 1); 
0626:  BSF    03,6
0627:  MOVF   2C,W
0628:  MOVWF  30
0629:  BCF    03,0
062A:  RRF    30,F
062B:  MOVF   30,W
062C:  MOVWF  45
062D:  BCF    03,6
062E:  CALL   3B0
....................                 oset = len - ROMPAGE_LEN; 
062F:  BSF    03,6
0630:  MOVF   2A,W
0631:  MOVWF  2E
0632:  MOVLW  20
0633:  SUBWF  2E,F
....................                 if (blk & 1) 
0634:  MOVF   2C,W
0635:  ANDLW  01
0636:  IORLW  00
0637:  BTFSS  03,2
0638:  GOTO   63B
0639:  BCF    03,6
063A:  GOTO   640
063B:  BCF    03,6
....................                     oset += 0x80; 
063C:  MOVLW  80
063D:  BSF    03,6
063E:  ADDWF  2E,F
063F:  BCF    03,6
....................                 i2c_write(oset); 
0640:  BSF    03,6
0641:  MOVF   2E,W
0642:  MOVWF  45
0643:  BCF    03,6
0644:  CALL   3B0
....................                 for (i=0; i<ROMPAGE_LEN; i++) 
0645:  BSF    03,6
0646:  CLRF   2D
0647:  BCF    03,6
0648:  MOVLW  20
0649:  BSF    03,6
064A:  SUBWF  2D,W
064B:  BTFSS  03,0
064C:  GOTO   64F
064D:  BCF    03,6
064E:  GOTO   661
064F:  BCF    03,6
....................                     i2c_write(txbuff[i]); 
0650:  MOVLW  A0
0651:  BSF    03,6
0652:  ADDWF  2D,W
0653:  BCF    03,6
0654:  MOVWF  04
0655:  BCF    03,7
0656:  MOVF   00,W
0657:  BSF    03,6
0658:  MOVWF  30
0659:  MOVF   30,W
065A:  MOVWF  45
065B:  BCF    03,6
065C:  CALL   3B0
065D:  BSF    03,6
065E:  INCF   2D,F
065F:  BCF    03,6
0660:  GOTO   648
....................                 i2c_stop(); 
0661:  BSF    03,5
0662:  BCF    07,4
0663:  NOP
0664:  BSF    07,3
0665:  BCF    03,5
0666:  BTFSS  07,3
0667:  GOTO   666
0668:  CLRWDT
0669:  NOP
066A:  NOP
066B:  NOP
066C:  BSF    03,5
066D:  BSF    07,4
066E:  CLRWDT
066F:  BCF    03,5
....................             } 
....................         } 
....................         else                            // End of block, send ACK 
0670:  GOTO   69E
....................         { 
....................             putchar(ACK); 
0671:  MOVLW  06
0672:  BTFSS  0C,4
0673:  GOTO   672
0674:  MOVWF  19
....................             timeout(ledticks, 0); 
0675:  BSF    03,6
0676:  CLRF   35
....................             SYSLED = !SYSLED; 
*
0696:  MOVLW  10
0697:  XORWF  05,F
....................             len = 0; 
0698:  BSF    03,6
0699:  CLRF   2A
....................             b1 = b2 = b3 = FALSE; 
069A:  BCF    2F,3
069B:  BCF    2F,2
069C:  BCF    2F,1
069D:  BCF    03,6
....................         } 
....................     } 
069E:  GOTO   572
.................... } 
....................  
.................... // EOF 
.................... 
....................  
.................... void main() 
.................... { 
....................     WORD pcol; 
*
14AB:  MOVLW  5F
14AC:  MOVWF  20
14AD:  MOVLW  21
14AE:  MOVWF  04
14AF:  MOVLW  00
14B0:  MOVWF  00
14B1:  INCF   04,F
14B2:  DECFSZ 20,F
14B3:  GOTO   4B0
14B4:  MOVLW  50
14B5:  MOVWF  77
14B6:  MOVLW  A0
14B7:  MOVWF  04
14B8:  MOVLW  00
14B9:  MOVWF  00
14BA:  INCF   04,F
14BB:  DECFSZ 77,F
14BC:  GOTO   4B9
14BD:  BSF    03,7
14BE:  MOVLW  6F
14BF:  BSF    03,6
14C0:  MOVWF  10
14C1:  MOVLW  11
14C2:  MOVWF  04
14C3:  MOVLW  00
14C4:  BCF    03,6
14C5:  MOVWF  00
14C6:  INCF   04,F
14C7:  BSF    03,6
14C8:  DECFSZ 10,F
14C9:  GOTO   4CB
14CA:  GOTO   4CD
14CB:  BCF    03,6
14CC:  GOTO   4C5
14CD:  MOVLW  60
14CE:  BCF    03,6
14CF:  MOVWF  77
14D0:  MOVLW  90
14D1:  MOVWF  04
14D2:  MOVLW  00
14D3:  MOVWF  00
14D4:  INCF   04,F
14D5:  DECFSZ 77,F
14D6:  GOTO   4D3
14D7:  BCF    03,7
14D8:  CLRF   04
14D9:  BCF    03,7
14DA:  MOVLW  1F
14DB:  ANDWF  03,F
14DC:  MOVLW  9F
14DD:  MOVWF  04
14DE:  BCF    03,7
14DF:  MOVLW  07
14E0:  MOVWF  00
14E1:  CLRF   20
14E2:  MOVLW  1F
14E3:  BSF    03,5
14E4:  MOVWF  19
14E5:  MOVLW  22
14E6:  MOVWF  18
14E7:  MOVLW  90
14E8:  BCF    03,5
14E9:  MOVWF  18
14EA:  CLRF   2A
14EB:  MOVLW  04
14EC:  MOVWF  2B
14ED:  MOVLW  A3
14EE:  MOVWF  2C
14EF:  CLRF   2D
14F0:  CLRF   2E
14F1:  CLRF   2F
14F2:  CLRF   72
14F3:  CLRF   74
14F4:  CLRF   75
....................  
....................     LCD_E = 0;                          // Disable LCD 
14F5:  BCF    05,5
....................     setup_adc_ports(RA0_ANALOG);        // RA0 analog I/P 
14F6:  MOVLW  9F
14F7:  MOVWF  04
14F8:  BCF    03,7
14F9:  MOVLW  8E
14FA:  MOVWF  00
....................     setup_adc(ADC_CLOCK_DIV_32); 
14FB:  MOVF   1F,W
14FC:  ANDLW  38
14FD:  IORLW  81
14FE:  MOVWF  1F
....................     SET_ADC_CHANNEL(0); 
14FF:  MOVLW  00
1500:  MOVWF  78
1501:  MOVF   1F,W
1502:  ANDLW  C7
1503:  IORWF  78,W
1504:  MOVWF  1F
....................     port_b_pullups(TRUE);               // Use pullups on port B 
1505:  MOVLW  81
1506:  MOVWF  04
1507:  BCF    03,7
1508:  BCF    00,7
.................... #if OLD_BOARD 
....................     set_tris_a(0x01);                   // Set I/O on port A 
.................... #else 
....................     set_tris_a(0x03); 
1509:  MOVLW  03
150A:  TRIS   5
.................... #endif 
....................     setup_timer_1(TIMER1_SET);          // Init timer 
150B:  MOVLW  35
150C:  MOVWF  10
....................     timeout(ledticks, 0); 
150D:  BSF    03,6
150E:  CLRF   35
....................     reset_ether();                      // Reset Ethernet (to free data bus) 
*
152E:  BCF    0A,4
152F:  CALL   0DA
1530:  BSF    0A,4
....................     init_lcd();                         // Init LCD 
1531:  BCF    0A,4
1532:  GOTO   140
1533:  BSF    0A,4
....................     disp_lcd = disp_serial = TRUE;      // Set display flags 
1534:  BSF    26,5
1535:  BSF    26,4
....................     printf(displays, SIGNON);           // ..and sign on 
*
00BB:  BCF    0A,0
00BC:  BCF    0A,1
00BD:  BCF    0A,2
00BE:  ADDWF  02,F
00BF:  RETLW  43
00C0:  RETLW  68
00C1:  RETLW  69
00C2:  RETLW  70
00C3:  RETLW  57
00C4:  RETLW  65
00C5:  RETLW  62
00C6:  RETLW  20
00C7:  RETLW  76
00C8:  RETLW  31
00C9:  RETLW  2E
00CA:  RETLW  30
00CB:  RETLW  33
00CC:  RETLW  0A
00CD:  RETLW  00
*
1536:  BSF    03,6
1537:  CLRF   25
1538:  BCF    03,6
1539:  BSF    03,6
153A:  MOVF   25,W
153B:  BCF    03,6
153C:  BCF    0A,4
153D:  CALL   0BB
153E:  BSF    0A,4
153F:  BSF    03,6
1540:  INCF   25,F
1541:  MOVWF  31
1542:  BCF    03,6
1543:  BCF    0A,4
1544:  CALL   185
1545:  BSF    0A,4
1546:  MOVLW  0E
1547:  BSF    03,6
1548:  SUBWF  25,W
1549:  BTFSC  03,2
154A:  GOTO   54D
154B:  BCF    03,6
154C:  GOTO   539
154D:  BCF    03,6
....................     while (!read_nonvol() || !USER_BUTTON)  // If csum error, or button 
154E:  BCF    0A,4
154F:  GOTO   1FA
1550:  BSF    0A,4
1551:  MOVF   78,F
1552:  BTFSC  03,2
1553:  GOTO   556
1554:  BTFSC  06,5
1555:  GOTO   572
....................     {            
....................         printf(displays, "Config "); 
*
00CE:  BCF    0A,0
00CF:  BCF    0A,1
00D0:  BCF    0A,2
00D1:  ADDWF  02,F
00D2:  RETLW  43
00D3:  RETLW  6F
00D4:  RETLW  6E
00D5:  RETLW  66
00D6:  RETLW  69
00D7:  RETLW  67
00D8:  RETLW  20
00D9:  RETLW  00
*
1556:  BSF    03,6
1557:  CLRF   25
1558:  BCF    03,6
1559:  BSF    03,6
155A:  MOVF   25,W
155B:  BCF    03,6
155C:  BCF    0A,4
155D:  CALL   0CE
155E:  BSF    0A,4
155F:  BSF    03,6
1560:  INCF   25,F
1561:  MOVWF  31
1562:  BCF    03,6
1563:  BCF    0A,4
1564:  CALL   185
1565:  BSF    0A,4
1566:  MOVLW  07
1567:  BSF    03,6
1568:  SUBWF  25,W
1569:  BTFSC  03,2
156A:  GOTO   56D
156B:  BCF    03,6
156C:  GOTO   559
....................         user_config();                      // ..call user config 
156D:  BCF    03,6
156E:  BCF    0A,4
156F:  GOTO   3EA
1570:  BSF    0A,4
....................     } 
1571:  GOTO   54E
....................     init_ether();                       // Init Ethernet 
1572:  BCF    0A,4
1573:  CALL   6C9
1574:  BSF    0A,4
....................     displays('\n');                     // Display IP address 
1575:  MOVLW  0A
1576:  BSF    03,6
1577:  MOVWF  31
1578:  BCF    03,6
1579:  BCF    0A,4
157A:  CALL   185
157B:  BSF    0A,4
....................     disp_decbyte(myip.b[3]); 
157C:  MOVF   51,W
157D:  BSF    03,6
157E:  MOVWF  25
157F:  BCF    03,6
1580:  BCF    0A,4
1581:  BSF    0A,3
1582:  CALL   05B
1583:  BSF    0A,4
1584:  BCF    0A,3
....................     displays('.'); 
1585:  MOVLW  2E
1586:  BSF    03,6
1587:  MOVWF  31
1588:  BCF    03,6
1589:  BCF    0A,4
158A:  CALL   185
158B:  BSF    0A,4
....................     disp_decbyte(myip.b[2]); 
158C:  MOVF   50,W
158D:  BSF    03,6
158E:  MOVWF  25
158F:  BCF    03,6
1590:  BCF    0A,4
1591:  BSF    0A,3
1592:  CALL   05B
1593:  BSF    0A,4
1594:  BCF    0A,3
....................     displays('.'); 
1595:  MOVLW  2E
1596:  BSF    03,6
1597:  MOVWF  31
1598:  BCF    03,6
1599:  BCF    0A,4
159A:  CALL   185
159B:  BSF    0A,4
....................     disp_decbyte(myip.b[1]); 
159C:  MOVF   4F,W
159D:  BSF    03,6
159E:  MOVWF  25
159F:  BCF    03,6
15A0:  BCF    0A,4
15A1:  BSF    0A,3
15A2:  CALL   05B
15A3:  BSF    0A,4
15A4:  BCF    0A,3
....................     displays('.'); 
15A5:  MOVLW  2E
15A6:  BSF    03,6
15A7:  MOVWF  31
15A8:  BCF    03,6
15A9:  BCF    0A,4
15AA:  CALL   185
15AB:  BSF    0A,4
....................     disp_decbyte(myip.b[0]); 
15AC:  MOVF   4E,W
15AD:  BSF    03,6
15AE:  MOVWF  25
15AF:  BCF    03,6
15B0:  BCF    0A,4
15B1:  BSF    0A,3
15B2:  CALL   05B
15B3:  BSF    0A,4
15B4:  BCF    0A,3
....................  
....................     while (1)                       // Main loop.. 
....................     { 
....................         scan_io();                  // Scan I/O, check timer 
15B5:  BCF    0A,4
15B6:  CALL   265
15B7:  BSF    0A,4
....................         rxin = rxout = 0; 
15B8:  CLRF   47
15B9:  CLRF   46
15BA:  MOVF   47,W
15BB:  MOVWF  45
15BC:  MOVF   46,W
15BD:  MOVWF  44
....................         atend = 0; 
15BE:  BCF    26,1
....................         if (get_ether())            // Get Ethernet frame.. 
15BF:  BCF    0A,4
15C0:  BSF    0A,3
15C1:  GOTO   0A5
15C2:  BSF    0A,4
15C3:  BCF    0A,3
15C4:  MOVF   78,W
15C5:  IORWF  79,W
15C6:  BTFSC  03,2
15C7:  GOTO   5E0
....................         {                            
....................             if (nicin.eth.pcol == PCOL_ARP) 
15C8:  MOVLW  08
15C9:  SUBWF  43,W
15CA:  BTFSS  03,2
15CB:  GOTO   5D6
15CC:  MOVLW  06
15CD:  SUBWF  42,W
15CE:  BTFSS  03,2
15CF:  GOTO   5D6
....................                 arp_recv();         // ..is it ARP? 
15D0:  BCF    0A,4
15D1:  BSF    0A,3
15D2:  GOTO   3EC
15D3:  BSF    0A,4
15D4:  BCF    0A,3
....................             else if (nicin.eth.pcol == PCOL_IP) 
15D5:  GOTO   5E0
15D6:  MOVLW  08
15D7:  SUBWF  43,W
15D8:  BTFSS  03,2
15D9:  GOTO   5E0
15DA:  MOVF   42,F
15DB:  BTFSS  03,2
15DC:  GOTO   5E0
....................                 ip_recv();          // ..or is it IP? 
15DD:  BSF    0A,3
15DE:  GOTO   000
15DF:  BCF    0A,3
....................         } 
....................     } 
15E0:  GOTO   5B5
.................... } 
....................  
15E1:  SLEEP
.................... /* Update the current tick count, return non-zero if changed */ 
.................... BOOL geticks(void) 
.................... { 
....................     static BYTE tc, lastc=0; 
....................  
....................     tc = TIMER_1_HIGH - lastc; 
*
0254:  MOVF   0F,W
0255:  MOVWF  74
0256:  MOVF   75,W
0257:  SUBWF  74,F
....................     if (tc >= TIMER1_DIV) 
0258:  MOVLW  78
0259:  SUBWF  74,W
025A:  BTFSS  03,0
025B:  GOTO   262
....................     { 
....................         tickcount++; 
025C:  INCF   25,F
....................         lastc += TIMER1_DIV; 
025D:  MOVLW  78
025E:  ADDWF  75,F
....................         return 1; 
025F:  MOVLW  01
0260:  MOVWF  78
0261:  GOTO   264
....................     } 
....................     return 0; 
0262:  MOVLW  00
0263:  MOVWF  78
0264:  RETLW  00
.................... } 
....................  
.................... /* Check for timeout using the given tick counter */ 
.................... BOOL timeout(int &var, int tout) 
.................... { 
*
029A:  BCF    36,0
*
0553:  BCF    36,0
*
0579:  BCF    36,0
*
0677:  BCF    36,0
*
150F:  BCF    36,0
....................     BOOL ret=0; 
....................  
....................     if (!tout || tickcount-var>=tout) 
*
029B:  MOVF   35,F
029C:  BTFSS  03,2
029D:  GOTO   2A0
029E:  BCF    03,6
029F:  GOTO   2AE
02A0:  BCF    03,6
02A1:  MOVF   27,W
02A2:  SUBWF  25,W
02A3:  BSF    03,6
02A4:  SUBWF  35,W
02A5:  BTFSS  03,2
02A6:  GOTO   2A9
02A7:  BCF    03,6
02A8:  GOTO   2AE
02A9:  BTFSS  03,0
02AA:  GOTO   2AD
02AB:  BCF    03,6
02AC:  GOTO   2B3
02AD:  BCF    03,6
*
0554:  MOVF   35,F
0555:  BTFSS  03,2
0556:  GOTO   559
0557:  BCF    03,6
0558:  GOTO   567
0559:  BCF    03,6
055A:  MOVF   27,W
055B:  SUBWF  25,W
055C:  BSF    03,6
055D:  SUBWF  35,W
055E:  BTFSS  03,2
055F:  GOTO   562
0560:  BCF    03,6
0561:  GOTO   567
0562:  BTFSS  03,0
0563:  GOTO   566
0564:  BCF    03,6
0565:  GOTO   56C
0566:  BCF    03,6
*
057A:  MOVF   35,F
057B:  BTFSS  03,2
057C:  GOTO   57F
057D:  BCF    03,6
057E:  GOTO   58D
057F:  BCF    03,6
0580:  MOVF   27,W
0581:  SUBWF  25,W
0582:  BSF    03,6
0583:  SUBWF  35,W
0584:  BTFSS  03,2
0585:  GOTO   588
0586:  BCF    03,6
0587:  GOTO   58D
0588:  BTFSS  03,0
0589:  GOTO   58C
058A:  BCF    03,6
058B:  GOTO   592
058C:  BCF    03,6
*
0678:  MOVF   35,F
0679:  BTFSS  03,2
067A:  GOTO   67D
067B:  BCF    03,6
067C:  GOTO   68B
067D:  BCF    03,6
067E:  MOVF   27,W
067F:  SUBWF  25,W
0680:  BSF    03,6
0681:  SUBWF  35,W
0682:  BTFSS  03,2
0683:  GOTO   686
0684:  BCF    03,6
0685:  GOTO   68B
0686:  BTFSS  03,0
0687:  GOTO   68A
0688:  BCF    03,6
0689:  GOTO   690
068A:  BCF    03,6
*
1510:  MOVF   35,F
1511:  BTFSS  03,2
1512:  GOTO   515
1513:  BCF    03,6
1514:  GOTO   523
1515:  BCF    03,6
1516:  MOVF   27,W
1517:  SUBWF  25,W
1518:  BSF    03,6
1519:  SUBWF  35,W
151A:  BTFSS  03,2
151B:  GOTO   51E
151C:  BCF    03,6
151D:  GOTO   523
151E:  BTFSS  03,0
151F:  GOTO   522
1520:  BCF    03,6
1521:  GOTO   528
1522:  BCF    03,6
....................     { 
....................         var = tickcount; 
*
02AE:  MOVF   25,W
02AF:  MOVWF  27
*
0567:  MOVF   25,W
0568:  MOVWF  27
*
058D:  MOVF   25,W
058E:  MOVWF  27
*
068B:  MOVF   25,W
068C:  MOVWF  27
*
1523:  MOVF   25,W
1524:  MOVWF  27
....................         ret = 1; 
*
02B0:  BSF    03,6
02B1:  BSF    36,0
02B2:  BCF    03,6
*
0569:  BSF    03,6
056A:  BSF    36,0
056B:  BCF    03,6
*
058F:  BSF    03,6
0590:  BSF    36,0
0591:  BCF    03,6
*
068D:  BSF    03,6
068E:  BSF    36,0
068F:  BCF    03,6
*
1525:  BSF    03,6
1526:  BSF    36,0
1527:  BCF    03,6
....................     } 
....................     return(ret); 
*
02B3:  MOVLW  00
02B4:  BSF    03,6
02B5:  BTFSC  36,0
02B6:  MOVLW  01
02B7:  BCF    03,6
02B8:  MOVWF  78
*
056C:  MOVLW  00
056D:  BSF    03,6
056E:  BTFSC  36,0
056F:  MOVLW  01
0570:  BCF    03,6
0571:  MOVWF  78
*
0592:  MOVLW  00
0593:  BSF    03,6
0594:  BTFSC  36,0
0595:  MOVLW  01
0596:  BCF    03,6
0597:  MOVWF  78
*
0690:  MOVLW  00
0691:  BSF    03,6
0692:  BTFSC  36,0
0693:  MOVLW  01
0694:  BCF    03,6
0695:  MOVWF  78
*
1528:  MOVLW  00
1529:  BSF    03,6
152A:  BTFSC  36,0
152B:  MOVLW  01
152C:  BCF    03,6
152D:  MOVWF  78
.................... } 
....................  
.................... /* Read ADC values 
.................... ** Briefly enable RA1 as analog I/P, as this disables RA3 as digital O/P */ 
.................... void read_adcs(void) 
.................... { 
....................     adc1 = READ_ADC();                      // Get first value 
*
0267:  BSF    1F,2
0268:  BTFSC  1F,2
0269:  GOTO   268
026A:  MOVF   1E,W
026B:  MOVWF  7A
026C:  BSF    03,5
026D:  MOVF   1E,W
026E:  BCF    03,5
026F:  MOVWF  21
0270:  MOVF   7A,W
0271:  MOVWF  22
....................     setup_adc_ports(RA0_RA1_RA3_ANALOG);    // Enable RA1 analog 
0272:  MOVLW  9F
0273:  MOVWF  04
0274:  BCF    03,7
0275:  MOVLW  84
0276:  MOVWF  00
....................     SET_ADC_CHANNEL(1);                     // Set multiplexer 
0277:  MOVLW  08
0278:  MOVWF  78
0279:  MOVF   1F,W
027A:  ANDLW  C7
027B:  IORWF  78,W
027C:  MOVWF  1F
....................     delay_us(10);                           // Allow to setle 
027D:  MOVLW  10
027E:  MOVWF  77
027F:  DECFSZ 77,F
0280:  GOTO   27F
....................     adc2 = READ_ADC();                      // Get 2nd value 
0281:  BSF    1F,2
0282:  BTFSC  1F,2
0283:  GOTO   282
0284:  MOVF   1E,W
0285:  MOVWF  7A
0286:  BSF    03,5
0287:  MOVF   1E,W
0288:  BCF    03,5
0289:  MOVWF  23
028A:  MOVF   7A,W
028B:  MOVWF  24
....................     setup_adc_ports(RA0_ANALOG);            // Restore RA1 and multiplexer 
028C:  MOVLW  9F
028D:  MOVWF  04
028E:  BCF    03,7
028F:  MOVLW  8E
0290:  MOVWF  00
....................     SET_ADC_CHANNEL(0); 
0291:  MOVLW  00
0292:  MOVWF  78
0293:  MOVF   1F,W
0294:  ANDLW  C7
0295:  IORWF  78,W
0296:  MOVWF  1F
.................... } 
....................  
.................... /* Check timer, scan ADCs, toggle LED if timeout */ 
.................... void scan_io(void) 
.................... { 
....................     WORD w; 
....................      
....................     restart_wdt();              // Kick watchdog 
*
0265:  CLRWDT
....................     geticks();                  // Get tick count 
0266:  CALL   254
....................     read_adcs();                // Read ADC values 
....................     if (timeout(ledticks, LEDTIME))    
*
0297:  MOVLW  0A
0298:  BSF    03,6
0299:  MOVWF  35
*
02B9:  MOVF   78,F
02BA:  BTFSC  03,2
02BB:  GOTO   2BE
....................         SYSLED = !SYSLED;       // Toggle system LED 
02BC:  MOVLW  10
02BD:  XORWF  05,F
02BE:  RETLW  00
.................... } 
....................  
.................... /* EOF */                            
